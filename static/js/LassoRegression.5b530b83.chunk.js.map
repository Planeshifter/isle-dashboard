{"version":3,"sources":["../node_modules/@babel/runtime/helpers/esm/readOnlyError.js","../node_modules/@isle-project/utils/multiply/index.js","../node_modules/@isle-project/utils/zscore/index.js","../node_modules/@isle-project/utils/divide/index.js","../node_modules/@isle-project/components/models/lasso-regression/dotm.js","../node_modules/@isle-project/components/models/lasso-regression/dotv.js","../node_modules/@isle-project/components/models/lasso-regression/soft_thresholding.js","../node_modules/@isle-project/components/models/lasso-regression/lasso.js","../node_modules/@isle-project/components/models/lasso-regression/main.js","../node_modules/@isle-project/utils/mmult/index.js","../node_modules/@isle-project/utils/subtract/index.js","../node_modules/@isle-project/utils/transpose/index.js","../node_modules/@stdlib/stdlib/lib/node_modules/@stdlib/assert/is-array-array/lib/index.js","../node_modules/@stdlib/stdlib/lib/node_modules/@stdlib/assert/is-array-array/lib/main.js","../node_modules/@stdlib/stdlib/lib/node_modules/@stdlib/utils/define-nonenumerable-property/lib/index.js","../node_modules/@stdlib/stdlib/lib/node_modules/@stdlib/utils/define-nonenumerable-property/lib/main.js"],"names":["_readOnlyError","name","TypeError","arr","x","isArr","isArrayLike","isNumber","len","length","out","Array","Error","i","demean","scale","avg","mean","sd","stdev","slice","setNonEnumerableProperty","opts","y","j","ret","nRows","shape","xVal","get","yVal","sum","t","debug","logger","matrix","ctor","PRECISION","mget","Float64Array","LassoFit","lambda","this","N","p","beta","betast","active","incrspace","nonactive","presid","_buffer","strides","offset","order","init","iteration","iterate","prototype","testKKT","ymxb","subtract","mmult","G","divide","transpose","abs","sign","testActiveSet","changed","residuals","predict","jVal","xj","dotv","push","splice","converged","rval","k","set","dotm","betaOld","betaNew","softThresholding","isArrayArray","ndarray","fitted","isMatrixLike","addResources","COUNTER","designMatrix","data","quantitative","intercept","isArray","predictors","hash","standardized","categoricalStats","nobs","contains","values","zScore","counts","countBy","identity","categories","objectKeys","label","mu","sigma","sqrt","row","val","fitModel","yvalues","result","LASSO","coefSum","pred","_","LassoRegression","props","state","multiply","onPredict","style","overflowX","width","className","toFixed","counter","bordered","size","map","idx","key","Number","summaryTable","tooltip","Button","variant","onClick","handlePredict","Alert","nextProps","prevState","Component","defaultProps","withTranslation","A","b","n","X","module","exports","arrayfun","defineProperty","obj","prop","value"],"mappings":"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","file":"static/js/LassoRegression.5b530b83.chunk.js","sourcesContent":["export default function _readOnlyError(name) {\n  throw new TypeError(\"\\\"\" + name + \"\\\" is read-only\");\n}","// MODULES //\n\nimport isArrayLike from '@stdlib/assert/is-array-like';\nimport { isPrimitive as isNumber } from '@stdlib/assert/is-number';\n\n\n// MAIN //\n\n/**\n* Computes an element-wise multiplication.\n*\n* @param {NumberArray} arr - input array\n* @param {(NumberArray|number)} x - either an array of equal length or a scalar\n* @returns {NumberArray} output array\n*/\nfunction multiply( arr, x ) {\n\tconst isArr = isArrayLike( x );\n\tif ( !isArrayLike( arr ) ) {\n\t\tthrow new TypeError( 'invalid input argument. Must provide an array. Value: `' + arr + '`.' );\n\t}\n\tif ( !isArr && !isNumber( x ) ) {\n\t\tthrow new TypeError( 'invalid input argument. Second argument must either be an array or number primitive. Value: `' + x + '`.' );\n\t}\n\tconst len = arr.length;\n\tconst out = new Array( len );\n\n\t// Case 1: x is an array\n\tif ( isArr ) {\n\t\tif ( len !== x.length ) {\n\t\t\tthrow new Error( 'invalid input argument. Array to be multiplied must have a length equal to that of the input array.' );\n\t\t}\n\t\tfor ( let i = 0; i < len; i++ ) {\n\t\t\tout[ i ] = arr[ i ] * x[ i ];\n\t\t}\n\t}\n\t// Case 2: scalar\n\telse {\n\t\tfor ( let i = 0; i < len; i++ ) {\n\t\t\tout[ i ] = arr[ i ] * x;\n\t\t}\n\t}\n\treturn out;\n}\n\n\n// EXPORTS //\n\nexport default multiply;\n","/**\n* Copyright (C) 2020-present The ISLE Authors\n*\n* The isle-dashboard program is free software: you can redistribute it and/or modify\n* it under the terms of the GNU Affero General Public License as\n* published by the Free Software Foundation, either version 3 of the\n* License, or (at your option) any later version.\n*\n* This program is distributed in the hope that it will be useful,\n* but WITHOUT ANY WARRANTY; without even the implied warranty of\n* MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n* GNU Affero General Public License for more details.\n*\n* You should have received a copy of the GNU Affero General Public License\n* along with this program.  If not, see <https://www.gnu.org/licenses/>.\n*/\n\n// MODULES //\n\nimport mean from '@isle-project/utils/statistic/mean';\nimport stdev from '@isle-project/utils/statistic/stdev';\nimport setNonEnumerableProperty from '@stdlib/utils/define-nonenumerable-property';\n\n\n// MAIN //\n\n/**\n* Standardizes elements in input array.\n*\n* @param {Array} x - input array\n* @param {boolean} demean - controls whether the mean should be subtracted from the values\n* @param {boolean} scale - controls whether values should be divided by the standard deviation\n* @returns {Array} output array with added `mu` and `sigma` properties\n*/\nfunction zScore( x, demean = true, scale = true ) {\n\tconst avg = mean( x );\n\tconst sd = stdev( x );\n\tconst len = x.length;\n\n\tconst out = new Array( len );\n\tif ( demean ) {\n\t\tif ( scale ) {\n\t\t\tfor ( let i = 0; i < len; i++ ) {\n\t\t\t\tout[ i ] = ( x[ i ] - avg ) / sd;\n\t\t\t}\n\t\t} else {\n\t\t\tfor ( let i = 0; i < len; i++ ) {\n\t\t\t\tout[ i ] = ( x[ i ] - avg );\n\t\t\t}\n\t\t}\n\t}\n\telse if ( scale ) {\n\t\tfor ( let i = 0; i < len; i++ ) {\n\t\t\tout[ i ] = x[ i ] / sd;\n\t\t}\n\t}\n\telse {\n\t\tout = x.slice();\n\t}\n\tsetNonEnumerableProperty( out, 'mu', avg );\n\tsetNonEnumerableProperty( out, 'sigma', sd );\n\treturn out;\n}\n\n\n// EXPORTS //\n\nexport default zScore;\n","// MODULES //\n\nimport isArrayLike from '@stdlib/assert/is-array-like';\nimport { isPrimitive as isNumber } from '@stdlib/assert/is-number';\n\n\n// MAIN //\n\n/**\n* Computes an element-wise division.\n*\n* @param {NumberArray} arr - input array\n* @param {(NumberArray|number)} x - either an array of equal length or a scalar\n* @returns {NumberArray} output array\n*/\nfunction divide( arr, x, opts ) {\n\tconst isArr = isArrayLike( x );\n\tif ( !isArrayLike( arr ) ) {\n\t\tthrow new TypeError( 'invalid input argument. Must provide an array. Value: `' + arr + '`.' );\n\t}\n\tif ( !isArr && !isNumber( x ) ) {\n\t\tthrow new TypeError( 'invalid input argument. Second argument must either be an array or number primitive. Value: `' + x + '`.' );\n\t}\n\tconst len = arr.length;\n\tconst out = new Array( len );\n\n\t// Case 1: x is an array\n\tif ( isArr ) {\n\t\tif ( len !== x.length ) {\n\t\t\tthrow new Error( 'invalid input argument. Array to be divided must have a length equal to that of the input array.' );\n\t\t}\n\t\tfor ( let i = 0; i < len; i++ ) {\n\t\t\tout[ i ] = arr[ i ] / x[ i ];\n\t\t}\n\t}\n\t// Case 2: scalar\n\telse {\n\t\tfor ( let i = 0; i < len; i++ ) {\n\t\t\tout[ i ] = arr[ i ] / x;\n\t\t}\n\t}\n\treturn out;\n}\n\n\n// EXPORTS //\n\nexport default divide;\n","// MAIN //\n\n/**\n* Calculates the dot product between j-th column vectors of the two input matrices skipping zero elements.\n*\n* @param {Matrix} x - first input matrix\n* @param {Matrix} y - second input matrix\n* @param {number} j - column index\n* @returns {number} dot product value\n*/\nfunction dotm( x, y, j ) {\n\tlet ret = 0.0;\n\tconst nRows = x.shape[ 0 ];\n\tfor ( let i = 0; i < nRows; i++ ) {\n\t\tconst xVal = x.get( i, j );\n\t\tconst yVal = y.get( i, j );\n\t\tif ( xVal !== 0 && yVal !== 0 ) {\n\t\t\tret += xVal * yVal;\n\t\t}\n\t}\n\treturn ret;\n}\n\n\n// EXPORTS //\n\nexport default dotm;\n","// MAIN //\n\n/**\n* Calculates the dot product between two arrays.\n*\n* @param {NumberArray} x - first vector\n* @param {NumberArray} y - second vector\n* @returns {number} dot product\n*/\nfunction dotv( x, y ) {\n\tconst len = x.length;\n\tlet sum = 0.0;\n\tfor ( let i = 0; i < len; i++ ) {\n\t\tsum += x[ i ] * y[ i ];\n\t}\n\treturn sum;\n}\n\n\n// EXPORTS //\n\nexport default dotv;\n","// MAIN //\n\n/**\n* Soft-thresholding operator.\n*\n* @param {number} x - input value\n* @param {number} t - threshold value\n* @returns {number} return value\n*/\nfunction softThresholding( x, t ) {\n\tif ( x > t ) {\n\t\treturn x - t;\n\t} else if ( x < -t ) {\n\t\treturn x + t;\n\t}\n\treturn 0;\n}\n\n\n// EXPORTS //\n\nexport default softThresholding;\n","// MODULES //\n\nimport logger from 'debug';\nimport incrspace from '@stdlib/math/utils/incrspace';\nimport sign from '@stdlib/math/base/special/signum';\nimport isArrayArray from '@stdlib/assert/is-array-array';\nimport isMatrixLike from '@stdlib/assert/is-matrix-like';\nimport ctor from '@stdlib/ndarray/ctor';\nimport ndarray from '@stdlib/ndarray/array';\nimport isNumber from '@stdlib/assert/is-number';\nimport isArrayLike from '@stdlib/assert/is-array-like';\nimport abs from '@stdlib/math/base/special/abs';\nimport mmult from '@isle-project/utils/mmult';\nimport transpose from '@isle-project/utils/transpose';\nimport subtract from '@isle-project/utils/subtract';\nimport divide from '@isle-project/utils/divide';\nimport dotm from './dotm.js';\nimport dotv from './dotv.js';\nimport softThresholding from './soft_thresholding.js';\n\n\n// VARIABLES //\n\nconst debug = logger( 'isle:lasso' );\nconst matrix = ctor( 'generic', 2 );\nconst PRECISION = 1e-9;\n\n\n// FUNCTIONS //\n\nconst mget = ( x, j ) => {\n\tconst out = new Float64Array( x.shape[ 0 ] );\n\tfor ( let i = 0; i < out.length; i++ ) {\n\t\tout[ i ] = x.get( i, j );\n\t}\n\treturn out;\n};\n\n\n// MAIN //\n\n/**\n* Lasso object to fit regression.\n*\n* @constructor\n* @returns {LassoFit} instance\n*/\nfunction LassoFit( y, x, lambda ) {\n\tthis.y = y;\n\tthis.x = x;\n\tthis.lambda = lambda;\n\n\tthis.N = x.shape[ 0 ];\n\tthis.p = x.shape[ 1 ];\n\n\t// Initialize model parameters to zero:\n\tthis.beta = new Float64Array( this.p );\n\tthis.betast = new Float64Array( this.p );\n\n\t// Initialize active set to all predictors:\n\tthis.active = incrspace( 0, this.beta.length, 1 );\n\tthis.nonactive = [];\n\n\t// Matrix holding partial residuals:\n\tthis.presid = matrix( new Float64Array( x._buffer.length ), x.shape, x.strides, x.offset, x.order );\n\n\tthis.init = () => {\n\t\tthis.iteration = 0;\n\t\tthis.iterate();\n\t};\n\tthis.init();\n}\n\n/**\n* Checks the Karush-Khun-Tucker (KKT) conditions for an optimal solution.\n*\n* @returns {boolean} returns true if optimal conditions are satisfied, false otherwise\n*/\nLassoFit.prototype.testKKT = function testKKT() {\n\tconst beta = this.beta;\n\tconst N = this.N;\n\tconst x = this.x;\n\tconst y = this.y;\n\n\tconst ymxb = subtract( y, mmult( x, beta ) );\n\tconst G = divide( mmult( transpose( x ), ymxb ), N );\n\tfor ( let i = 0; i < beta.length; i++ ) {\n\t\tif ( beta[ i ] === 0 ) {\n\t\t\tif ( abs( G[i] ) > this.lambda + PRECISION ) {\n\t\t\t\treturn false;\n\t\t\t}\n\t\t} else if ( beta[ i ] > 0 ) {\n\t\t\tif ( G[i] - this.lambda * sign( beta[i] ) > PRECISION ) {\n\t\t\t\treturn false;\n\t\t\t}\n\t\t}\n\t}\n\treturn true;\n};\n\n/**\n* Exclusion test for all predictors not in active set. If one or more predictors fail the test, they are included in the active set.\n*\n* @returns {boolean} returns true if active set was changed, false otherwise\n*/\nLassoFit.prototype.testActiveSet = function testActiveSet() {\n\tlet changed = false;\n\n\tconst { residuals } = this.predict( this.x );\n\n\t// See whether non-active variables all pass exclusion test:\n\tfor ( let j = 0; j < this.nonactive.length; j++ ) {\n\t\tconst jVal = this.nonactive[ j ];\n\t\tconst xj = mget( this.x, jVal );\n\t\tif ( abs( dotv( xj, residuals ) ) / this.N > this.lambda ) {\n\t\t\t// Test failed: include predictor in active set -> iterate again\n\t\t\tthis.active.push( jVal );\n\t\t\tthis.nonactive.splice( j, 1 );\n\t\t\tchanged = true;\n\t\t}\n\t}\n\tdebug( 'Active set changes...' );\n\treturn changed;\n};\n\n/**\n* Iterate over the active set of predictors and perform coordinate descent until convergence.\n*\n* @returns {void}\n*/\nLassoFit.prototype.iterate = function iterate() {\n\tconst N = this.N;\n\tconst p = this.p;\n\tconst x = this.x;\n\tconst y = this.y;\n\n\tthis.iteration += 1;\n\tif ( this.iteration > 10000 ) {\n\t\t// Break out after maximum number of iterations is reached...\n\t\treturn;\n\t}\n\n\tlet converged = true;\n\tfor ( let j = 0; j < this.active.length; j++ ) {\n\t\tconst jVal = this.active[ j ];\n\t\tfor ( let i = 0; i < N; i++ ) {\n\t\t\tconst rval = y[ i ];\n\t\t\tfor ( let k = 0; k < p; k++ ) {\n\t\t\t\trval -= ( jVal !== k ) ? x.get( i, k ) * this.beta[ k ] : 0;\n\t\t\t}\n\t\t\tthis.presid.set( i, jVal, rval );\n\t\t}\n\t\tthis.betast[ jVal ] = (1/N) * dotm( x, this.presid, jVal );\n\t\tconst betaOld = this.beta[ jVal ];\n\t\tconst betaNew = softThresholding( this.betast[ jVal ], this.lambda );\n\t\tif ( abs( betaNew - betaOld ) > PRECISION ) {\n\t\t\tconverged = false;\n\t\t}\n\t\tthis.beta[ jVal ] = betaNew;\n\t}\n\t// Recompute active set:\n\tfor ( let j = this.active.length - 1; j >= 0; j-- ) {\n\t\tconst jVal = this.active[ j ];\n\t\tif ( abs( this.beta[ jVal ] ) < PRECISION ) {\n\t\t\tthis.active.splice( j, 1 );\n\t\t\tthis.nonactive.push( jVal );\n\t\t}\n\t}\n\tif ( converged === false ) {\n\t\tthis.iterate();\n\t} else if ( this.testActiveSet() ) {\n\t\tthis.iterate();\n\t}\n};\n\n/**\n* Calculates the current model fitted values (yhat) and residuals (e = y - yhat).\n*\n* @returns {Object} fitted values and residuals\n*/\nLassoFit.prototype.predict = function predict( x ) {\n\tif ( isArrayArray( x ) ) {\n\t\tx = ndarray( x );\n\t}\n\tconst fitted = mmult( x, this.beta );\n\tconst residuals = new Array( this.N );\n\tfor ( let i = 0; i < this.N; i++ ) {\n\t\tresiduals[ i ] = this.y[ i ] - fitted[ i ];\n\t}\n\treturn { fitted, residuals };\n};\n\n\n// MAIN //\n\n/**\n* Fit lasso regression via coordinate descent.\n*\n* @param {Matrix|Array} x - design matrix\n* @param {NumberArray} y - response vector\n* @param {number} lambda - L1 penalty value\n* @returns {Object} regression model\n*/\nfunction lasso( x, y, lambda ) {\n\tif ( !isNumber ) {\n\t\tthrow new TypeError( 'invalid input argument. The third argument must be a number primitive. Value: `' + lambda + '`' );\n\t}\n\tif ( !isArrayLike( y ) ) {\n\t\tthrow new TypeError( 'invalid input argument. The second argument must be array-like. Value: `' + y + '`' );\n\t}\n\tif ( isArrayArray( x ) ) {\n\t\tx = ndarray( x );\n\t} else if ( !isMatrixLike( x ) ) {\n\t\tconst msg = 'invalid input argument. The first argument must be a matrix or an array-of-arrays. Value: `' + x + '`';\n\t\tthrow new TypeError( msg );\n\t}\n\treturn new LassoFit( y, x, lambda );\n}\n\n\n// EXPORTS //\n\nexport default lasso;\n","// MODULES //\n\nimport React, { Component } from 'react';\nimport PropTypes from 'prop-types';\nimport { withTranslation } from 'react-i18next';\nimport Alert from 'react-bootstrap/Alert';\nimport contains from '@stdlib/assert/contains';\nimport isArray from '@stdlib/assert/is-array';\nimport { isPrimitive as isNumber } from '@stdlib/assert/is-number';\nimport countBy from '@stdlib/utils/count-by';\nimport identity from '@stdlib/utils/identity-function';\nimport objectKeys from '@stdlib/utils/keys';\nimport sqrt from '@stdlib/math/base/special/sqrt';\nimport Button from 'react-bootstrap/Button';\nimport Tooltip from '@isle-project/components/tooltip';\nimport Table from '@isle-project/components/table';\nimport multiply from '@isle-project/utils/multiply';\nimport zScore from '@isle-project/utils/zscore';\nimport { addResources } from '@isle-project/locales';\nimport LASSO from './lasso.js';\n\n\n// VARIABLES //\n\naddResources( 'StatisticalModels' );\nlet COUNTER = 0;\n\n\n// FUNCTIONS //\n\nconst summaryTable = ( x, intercept, result, t ) => {\n\treturn (\n\t\t<Table bordered size=\"sm\">\n\t\t\t<thead>\n\t\t\t\t<tr>\n\t\t\t\t\t<th>{t('predictor')}</th>\n\t\t\t\t\t<th>{t('coefficient')}</th>\n\t\t\t\t</tr>\n\t\t\t</thead>\n\t\t\t<tbody>\n\t\t\t\t{ intercept ? <tr>\n\t\t\t\t\t<th>{t('intercept')}</th>\n\t\t\t\t\t<td>{result.beta[ 0 ].toFixed( 6 )}</td>\n\t\t\t\t</tr> : null }\n\t\t\t\t{x.map( ( name, idx ) => {\n\t\t\t\t\treturn (\n\t\t\t\t\t\t<tr key={idx} >\n\t\t\t\t\t\t\t<th>{name}</th>\n\t\t\t\t\t\t\t<td>{result.beta[ idx+Number(intercept) ].toFixed( 6 )}</td>\n\t\t\t\t\t\t</tr>\n\t\t\t\t\t);\n\t\t\t\t})}\n\t\t\t</tbody>\n\t\t</Table>\n\t);\n};\n\nfunction designMatrix( x, data, quantitative, intercept ) {\n\tif ( !isArray( x ) ) {\n\t\tx = [ x ];\n\t}\n\tconst matrix = [];\n\tconst predictors = [];\n\tconst hash = {};\n\tconst standardized = {};\n\tconst categoricalStats = {};\n\tconst nobs = data[ x[ 0 ] ].length;\n\tfor ( let j = 0; j < x.length; j++ ) {\n\t\tif ( contains( quantitative, x[ j ] ) ) {\n\t\t\tconst values = zScore( data[ x[ j ] ] );\n\t\t\tstandardized[ x[ j ] ] = values;\n\t\t\tpredictors.push( x[ j ] );\n\t\t} else {\n\t\t\tconst values = data[ x[ j ] ];\n\t\t\tconst counts = countBy( values, identity );\n\t\t\tconst categories = x[ j ].categories || objectKeys( counts );\n\t\t\tfor ( let k = intercept ? 1 : 0; k < categories.length; k++ ) {\n\t\t\t\tconst label = `${x[ j ]}_${categories[ k ]}`;\n\t\t\t\tpredictors.push( label );\n\t\t\t\tconst p = counts[ categories[ k ] ] / nobs;\n\t\t\t\tcategoricalStats[ label ] = {\n\t\t\t\t\tmu: p,\n\t\t\t\t\tsigma: sqrt( p * (1-p) )\n\t\t\t\t};\n\t\t\t}\n\t\t\thash[ x[ j ] ] = categories;\n\t\t}\n\t}\n\tfor ( let i = 0; i < nobs; i++ ) {\n\t\tconst row = [];\n\t\tif ( intercept ) {\n\t\t\trow.push( 1 );\n\t\t}\n\t\tfor ( let j = 0; j < x.length; j++ ) {\n\t\t\tif ( contains( quantitative, x[ j ] ) ) {\n\t\t\t\tconst values = standardized[ x[ j ] ];\n\t\t\t\trow.push( values[ i ] );\n\t\t\t} else {\n\t\t\t\tconst values = data[ x[ j ] ];\n\t\t\t\tconst categories = hash[ x[ j ] ];\n\t\t\t\tconst val = values[ i ];\n\t\t\t\tfor ( let k = intercept ? 1 : 0; k < categories.length; k++ ) {\n\t\t\t\t\tconst { mu, sigma } = categoricalStats[ `${x[ j ]}_${categories[ k ]}` ];\n\t\t\t\t\trow.push(\n\t\t\t\t\t\t( val === categories[ k ] ) ?\n\t\t\t\t\t\t( 1 - mu ) / sigma :\n\t\t\t\t\t\t-mu / sigma\n\t\t\t\t\t);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tmatrix.push( row );\n\t}\n\treturn { matrix, predictors, categoricalStats, standardized };\n}\n\nconst fitModel = ({ x, y, lambda, data, quantitative, intercept }) => {\n\ttry {\n\t\tlet yvalues = data[ y ];\n\t\tyvalues = zScore( yvalues, false, true );\n\t\tconst { matrix, predictors, categoricalStats, standardized } = designMatrix( x, data, quantitative, intercept );\n\t\tconst result = new LASSO( matrix, yvalues, lambda );\n\n\t\t// Convert back coefficients to original scale:\n\t\tif ( intercept ) {\n\t\t\tlet coefSum = 0.0;\n\t\t\tfor ( let i = 1; i < result.beta.length; i++ ) {\n\t\t\t\tconst pred = predictors[ i-1 ];\n\t\t\t\tif ( contains( quantitative, pred ) ) {\n\t\t\t\t\tresult.beta[ i ] *= yvalues.sigma / standardized[ pred ].sigma;\n\t\t\t\t\tcoefSum += ( result.beta[ i ] * standardized[ pred ].mu );\n\t\t\t\t} else {\n\t\t\t\t\tresult.beta[ i ] *= yvalues.sigma / categoricalStats[ pred ].sigma;\n\t\t\t\t\tcoefSum += ( result.beta[ i ] * categoricalStats[ pred ].mu );\n\t\t\t\t}\n\t\t\t}\n\t\t\tresult.beta[ 0 ] = yvalues.mu - coefSum;\n\t\t} else {\n\t\t\tfor ( let i = 0; i < result.beta.length; i++ ) {\n\t\t\t\tconst pred = predictors[ i ];\n\t\t\t\tif ( contains( quantitative, pred ) ) {\n\t\t\t\t\tresult.beta[ i ] *= yvalues.sigma / standardized[ pred ].sigma;\n\t\t\t\t} else {\n\t\t\t\t\tresult.beta[ i ] *= yvalues.sigma / categoricalStats[ pred ].sigma;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\treturn {\n\t\t\tpredictors,\n\t\t\tresult,\n\t\t\tyvalues\n\t\t};\n\t} catch ( _ ) {\n\t\treturn {};\n\t}\n};\n\n\n// MAIN //\n\n/**\n* LASSO regression.\n*\n* @property {Object} data - object of value arrays\n* @property {string} y - outcome variable\n* @property {Array<string>} x - one or more predictor variables\n* @property {Array<string>} quantitative - array of variables in `data` that are `quantitative`\n* @property {number} lambda - regularization parameter\n* @property {boolean} intercept - controls whether to fit a model with an intercept term\n* @property {Function} onPredict - callback invoked with predictions and residuals after model fitting\n*/\nclass LassoRegression extends Component {\n\tconstructor( props ) {\n\t\tsuper( props );\n\n\t\tCOUNTER += 1;\n\t\tconst { x, y, lambda, data, quantitative, intercept } = props;\n\t\tthis.state = {\n\t\t\t...fitModel({ x, y, lambda, data, quantitative, intercept }),\n\t\t\t...props\n\t\t};\n\t}\n\n\tstatic getDerivedStateFromProps( nextProps, prevState ) {\n\t\tif (\n\t\t\tnextProps.data !== prevState.data ||\n\t\t\tnextProps.quantitative !== prevState.quantitative ||\n\t\t\tnextProps.x !== prevState.x ||\n\t\t\tnextProps.y !== prevState.y ||\n\t\t\tnextProps.intercept !== prevState.intercept ||\n\t\t\tnextProps.lambda !== prevState.lambda\n\t\t) {\n\t\t\tconst { x, y, lambda, data, quantitative, intercept } = nextProps;\n\t\t\treturn {\n\t\t\t\t...fitModel({ x, y, lambda, data, quantitative, intercept }),\n\t\t\t\t...nextProps\n\t\t\t};\n\t\t}\n\t\treturn null;\n\t}\n\n\thandlePredict = () => {\n\t\tconst { matrix } = designMatrix( this.props.x, this.props.data, this.props.quantitative, this.props.intercept );\n\t\tlet { fitted, residuals } = this.state.result.predict( matrix );\n\n\t\t// Convert fitted values and residuals back to original scale before standardizing:\n\t\tfitted = multiply( fitted, this.state.yvalues.sigma );\n\t\tresiduals = multiply( residuals, -this.state.yvalues.sigma );\n\t\tthis.props.onPredict( fitted, residuals, COUNTER );\n\t}\n\n\trender() {\n\t\tconst { y, intercept, lambda, onPredict, t } = this.props;\n\t\tconst { result, predictors } = this.state;\n\t\tif ( !result ) {\n\t\t\treturn <Alert variant=\"danger\">{t('missing-attributes')}</Alert>;\n\t\t}\n\t\tif ( !isNumber( lambda ) ) {\n\t\t\treturn <Alert variant=\"danger\">{t('lambda-not-number')}</Alert>;\n\t\t}\n\t\treturn (\n\t\t\t<div style={{ overflowX: 'auto', width: '100%' }}>\n\t\t\t\t<span className=\"title\" >{t('lasso-title', { y, lambda: lambda.toFixed( 4 ), counter: COUNTER })}</span>\n\t\t\t\t{summaryTable( predictors, intercept, result, t )}\n\t\t\t\t<p>{result.testKKT() ? t('kkt-satisfied') : t('kkt-not-satisfied')}</p>\n\t\t\t\t{onPredict ? <Tooltip tooltip={t('use-model-to-predict-tooltip')} >\n\t\t\t\t\t<Button variant=\"secondary\" size=\"sm\" onClick={this.handlePredict}>{this.props.t('use-model-to-predict')}</Button>\n\t\t\t\t</Tooltip> : null}\n\t\t\t</div>\n\t\t);\n\t}\n}\n\n\n// PROPERTIES //\n\nLassoRegression.defaultProps = {\n\tlambda: 1e-3,\n\tintercept: true\n};\n\nLassoRegression.propTypes = {\n\tdata: PropTypes.object.isRequired,\n\ty: PropTypes.string.isRequired,\n\tx: PropTypes.oneOfType([\n\t\tPropTypes.arrayOf( PropTypes.string ),\n\t\tPropTypes.string\n\t]).isRequired,\n\tquantitative: PropTypes.arrayOf( PropTypes.string ).isRequired,\n\tlambda: PropTypes.number,\n\tintercept: PropTypes.bool\n};\n\n\n// EXPORTS //\n\nexport default withTranslation( 'StatisticalModels' )( LassoRegression );\n","/**\n* Computes a matrix product of a n x p matrix and a column vector of length p.\n*\n* @param {Matrix} A - n x p matrix\n* @param {Array} b - p x 1 column vector\n* @returns {Array} result of matrix multiplication\n*/\nfunction mmult( A, b ) {\n\tconst n = A.shape[ 0 ];\n\tconst p = A.shape[ 1 ];\n\n\tlet ret = new Float64Array( n );\n\tfor ( let i = 0; i < n; i++ ) {\n\t\t\tlet sum = 0;\n\t\t\tfor ( let j = 0; j < p; j++ ) {\n\t\t\t\tsum += A.get( i, j ) * b[ j ];\n\t\t\t}\n\t\t\tret[ i ] = sum;\n\t}\n\treturn ret;\n}\n\n\n// EXPORTS //\n\nexport default mmult;\n","// MODULES //\n\nimport isArrayLike from '@stdlib/assert/is-array-like';\nimport { isPrimitive as isNumber } from '@stdlib/assert/is-number';\n\n\n// MAIN //\n\n/**\n* Computes an element-wise subtraction.\n*\n* @param {NumberArray} arr - input array\n* @param {(NumberArray|number)} x - either an array of equal length or a scalar\n* @returns {NumberArray} output array\n*/\nfunction subtract( arr, x ) {\n\tconst isArr = isArrayLike( x );\n\tif ( !isArrayLike( arr ) ) {\n\t\tthrow new TypeError( 'invalid input argument. Must provide an array. Value: `' + arr + '`.' );\n\t}\n\tif ( !isArr && !isNumber( x ) ) {\n\t\tthrow new TypeError( 'invalid input argument. Second argument must either be an array or number primitive. Value: `' + x + '`.' );\n\t}\n\tconst len = arr.length;\n\tconst out = new Array( len );\n\n\t// Case 1: x is an array\n\tif ( isArr ) {\n\t\tif ( len !== x.length ) {\n\t\t\tthrow new Error( 'invalid input argument. Array to be added must have a length equal to that of the input array.' );\n\t\t}\n\t\tfor ( let i = 0; i < len; i++ ) {\n\t\t\tout[ i ] = arr[ i ] - x[ i ];\n\t\t}\n\t}\n\t// Case 2: scalar\n\telse {\n\t\tfor ( let i = 0; i < len; i++ ) {\n\t\t\tout[ i ] = arr[ i ] - x;\n\t\t}\n\t}\n\treturn out;\n}\n\n\n// EXPORTS //\n\nexport default subtract;\n","/**\n* Copyright (C) 2020-present The ISLE Authors\n*\n* The isle-dashboard program is free software: you can redistribute it and/or modify\n* it under the terms of the GNU Affero General Public License as\n* published by the Free Software Foundation, either version 3 of the\n* License, or (at your option) any later version.\n*\n* This program is distributed in the hope that it will be useful,\n* but WITHOUT ANY WARRANTY; without even the implied warranty of\n* MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n* GNU Affero General Public License for more details.\n*\n* You should have received a copy of the GNU Affero General Public License\n* along with this program.  If not, see <https://www.gnu.org/licenses/>.\n*/\n\n// MODULES //\n\nimport ctor from '@stdlib/ndarray/ctor';\n\n\n// VARIABLES //\n\nconst matrix = ctor( 'float64', 2 );\n\n\n// MAIN //\n\n/**\n* Transposes a matrix.\n*\n* @param {Matrix} X - input matrix (2d `ndarray`)\n* @returns matrix transpose\n*/\nconst transpose = ( X ) => {\n\tconst shape = [ X.shape[ 1 ], X.shape[ 0 ] ];\n\tconst strides = [ X.strides[ 1 ], X.strides[ 0 ] ];\n\tconst offset = X.offset;\n\tconst order = X.order;\n\treturn matrix( X._buffer, shape, strides, offset, order );\n};\n\n\n// EXPORTS //\n\nexport default transpose;\n","/**\n* @license Apache-2.0\n*\n* Copyright (c) 2018 The Stdlib Authors.\n*\n* Licensed under the Apache License, Version 2.0 (the \"License\");\n* you may not use this file except in compliance with the License.\n* You may obtain a copy of the License at\n*\n*    http://www.apache.org/licenses/LICENSE-2.0\n*\n* Unless required by applicable law or agreed to in writing, software\n* distributed under the License is distributed on an \"AS IS\" BASIS,\n* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n* See the License for the specific language governing permissions and\n* limitations under the License.\n*/\n'use strict';\n/**\n* Test if a value is an array of arrays.\n*\n* @module @stdlib/assert/is-array-array\n*\n* @example\n* var isArrayArray = require( '@stdlib/assert/is-array-array' );\n*\n* var bool = isArrayArray( [ [], [] ] );\n* // returns true\n*\n* bool = isArrayArray( [ {}, {} ] );\n* // returns false\n*\n* bool = isArrayArray( [] );\n* // returns false\n*/\n// MODULES //\n\nvar isArrayArray = require('./main.js'); // EXPORTS //\n\n\nmodule.exports = isArrayArray;","/**\n* @license Apache-2.0\n*\n* Copyright (c) 2018 The Stdlib Authors.\n*\n* Licensed under the Apache License, Version 2.0 (the \"License\");\n* you may not use this file except in compliance with the License.\n* You may obtain a copy of the License at\n*\n*    http://www.apache.org/licenses/LICENSE-2.0\n*\n* Unless required by applicable law or agreed to in writing, software\n* distributed under the License is distributed on an \"AS IS\" BASIS,\n* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n* See the License for the specific language governing permissions and\n* limitations under the License.\n*/\n'use strict'; // MODULES //\n\nvar arrayfun = require('@stdlib/assert/tools/array-function');\n\nvar isArray = require('@stdlib/assert/is-array'); // MAIN //\n\n/**\n* Tests if a value is an array of arrays.\n*\n* @name isArrayArray\n* @type {Function}\n* @param {*} value - value to test\n* @returns {boolean} boolean indicating whether a value is an array of arrays\n*\n* @example\n* var bool = isArrayArray( [ [], [] ] );\n* // returns true\n*\n* bool = isArrayArray( [ {}, {} ] );\n* // returns false\n*\n* bool = isArrayArray( [] );\n* // returns false\n*/\n\n\nvar isArrayArray = arrayfun(isArray); // EXPORTS //\n\nmodule.exports = isArrayArray;","/**\n* @license Apache-2.0\n*\n* Copyright (c) 2018 The Stdlib Authors.\n*\n* Licensed under the Apache License, Version 2.0 (the \"License\");\n* you may not use this file except in compliance with the License.\n* You may obtain a copy of the License at\n*\n*    http://www.apache.org/licenses/LICENSE-2.0\n*\n* Unless required by applicable law or agreed to in writing, software\n* distributed under the License is distributed on an \"AS IS\" BASIS,\n* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n* See the License for the specific language governing permissions and\n* limitations under the License.\n*/\n'use strict';\n/**\n* Define a non-enumerable property.\n*\n* @module @stdlib/utils/define-nonenumerable-property\n*\n* @example\n* var objectKeys = require( '@stdlib/utils/keys' );\n* var setNonEnumerableProperty = require( '@stdlib/utils/define-nonenumerable-property' );\n*\n* var obj = {};\n*\n* setNonEnumerableProperty( obj, 'foo', 'bar' );\n*\n* var v = obj.foo;\n* // returns 'bar'\n*\n* var keys = objectKeys( obj );\n* // returns []\n*/\n// MODULES //\n\nvar setNonEnumerableProperty = require('./main.js'); // EXPORTS //\n\n\nmodule.exports = setNonEnumerableProperty;","/**\n* @license Apache-2.0\n*\n* Copyright (c) 2018 The Stdlib Authors.\n*\n* Licensed under the Apache License, Version 2.0 (the \"License\");\n* you may not use this file except in compliance with the License.\n* You may obtain a copy of the License at\n*\n*    http://www.apache.org/licenses/LICENSE-2.0\n*\n* Unless required by applicable law or agreed to in writing, software\n* distributed under the License is distributed on an \"AS IS\" BASIS,\n* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n* See the License for the specific language governing permissions and\n* limitations under the License.\n*/\n'use strict'; // MODULES //\n\nvar defineProperty = require('@stdlib/utils/define-property'); // MAIN //\n\n/**\n* Defines a non-enumerable property.\n*\n* @param {Object} obj - object on which to define the property\n* @param {(string|symbol)} prop - property name\n* @param {*} value - value to set\n*\n* @example\n* var objectKeys = require( '@stdlib/utils/keys' );\n*\n* var obj = {};\n*\n* setNonEnumerableProperty( obj, 'foo', 'bar' );\n*\n* var v = obj.foo;\n* // returns 'bar'\n*\n* var keys = objectKeys( obj );\n* // returns []\n*/\n\n\nfunction setNonEnumerableProperty(obj, prop, value) {\n  defineProperty(obj, prop, {\n    'configurable': true,\n    'enumerable': false,\n    'writable': true,\n    'value': value\n  });\n} // EXPORTS //\n\n\nmodule.exports = setNonEnumerableProperty;"],"sourceRoot":""}