{"version":3,"sources":["../node_modules/ml-distance-euclidean/lib-es6/euclidean.js","../node_modules/ml-nearest-vector/lib-es6/index.js","../node_modules/ml-kmeans/src/utils.js","../node_modules/ml-xsadd/lib-es6/xsadd.js","../node_modules/ml-random/lib-es6/choice.js","../node_modules/ml-random/lib-es6/index.js","../node_modules/ml-kmeans/src/initialization.js","../node_modules/ml-kmeans/src/KMeansResult.js","../node_modules/ml-kmeans/src/kmeans.js","../node_modules/@isle-project/components/models/kmeans/main.js"],"names":["squaredEuclidean","p","q","d","i","length","defaultOptions","distanceFunction","nearestVector","listVectors","vector","options","arguments","undefined","similarityFunction","vectorIndex","maxSim","Number","MIN_VALUE","j","sim","Error","minDist","MAX_VALUE","dist","updateClusterID","data","centers","clusterID","distance","XSadd","seed","Date","now","this","state","Uint32Array","init","random","getFloat","bind","key","value","nextState","getUint32","isInteger","TypeError","n","m","nlo","periodCertification","_i","t","getArray","arr","push","randomIndex","cumSum","rand","idx","Math","floor","values","valuesArr","_options$size","size","_options$replace","replace","probabilities","slice","abs","concat","result","index","splice","Random","seedOrRandom","xsadd","randomGenerator","low","high","euclideanDistances","A","B","rows","set","getRow","range","l","r","distanceSymbol","Symbol","KMeansResult","clusters","centroids","converged","iterations","Array","map","centroid","enrichedCentroids","error","_marked","mark","kmeansGenerator","maxIterations","tolerance","withIterations","initialization","step","K","newCenters","prevCenters","nDim","centersLen","dim","id","updateCenters","oldCenters","hasConverged","stepNumber","stepResult","wrap","_context","prev","next","computeInformation","stop","kmeans","Object","assign","isArray","X","nSamples","localTrials","log","firstCenterIdx","randInt","closestDistSquared","cumSumClosestDistSquared","factor","mul","candidateIdx","choice","distanceToCandidates","selection","columns","bestCandidate","bestPot","bestDistSquared","newDistSquared","min","newPot","sum","kmeanspp","distanceMatrix","ans","maxDist","k","center","minDistCent","indexOf","mostDistant","calculateDistanceMatrix","addResources","fitModel","variables","matrix","hasOwnProp","x","row","missing","val","isNumber","isnan","_","KMeans","props","onResult","style","overflowX","width","className","bordered","name","toFixed","summaryTable","Alert","variant","nextProps","prevState","Component","defaultProps","withTranslation"],"mappings":"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","file":"static/js/933.976356ec.chunk.js","sourcesContent":["export function squaredEuclidean(p, q) {\n  var d = 0;\n\n  for (var i = 0; i < p.length; i++) {\n    d += (p[i] - q[i]) * (p[i] - q[i]);\n  }\n\n  return d;\n}\nexport function euclidean(p, q) {\n  return Math.sqrt(squaredEuclidean(p, q));\n}","'use strict';\n\nimport { squaredEuclidean } from 'ml-distance-euclidean';\nvar defaultOptions = {\n  distanceFunction: squaredEuclidean\n};\nexport default function nearestVector(listVectors, vector) {\n  var options = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : defaultOptions;\n  var distanceFunction = options.distanceFunction || defaultOptions.distanceFunction;\n  var similarityFunction = options.similarityFunction || defaultOptions.similarityFunction;\n  var vectorIndex = -1;\n\n  if (typeof similarityFunction === 'function') {\n    // maximum similarity\n    var maxSim = Number.MIN_VALUE;\n\n    for (var j = 0; j < listVectors.length; j++) {\n      var sim = similarityFunction(vector, listVectors[j]);\n\n      if (sim > maxSim) {\n        maxSim = sim;\n        vectorIndex = j;\n      }\n    }\n  } else if (typeof distanceFunction === 'function') {\n    // minimum distance\n    var minDist = Number.MAX_VALUE;\n\n    for (var i = 0; i < listVectors.length; i++) {\n      var dist = distanceFunction(vector, listVectors[i]);\n\n      if (dist < minDist) {\n        minDist = dist;\n        vectorIndex = i;\n      }\n    }\n  } else {\n    throw new Error(\"A similarity or distance function it's required\");\n  }\n\n  return vectorIndex;\n}\nexport function findNearestVector(vectorList, vector) {\n  var options = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : defaultOptions;\n  var index = nearestVector(vectorList, vector, options);\n  return vectorList[index];\n}","import nearestVector from 'ml-nearest-vector';\n/**\n * Calculates the distance matrix for a given array of points\n * @ignore\n * @param {Array<Array<number>>} data - the [x,y,z,...] points to cluster\n * @param {function} distance - Distance function to use between the points\n * @return {Array<Array<number>>} - matrix with the distance values\n */\n\nexport function calculateDistanceMatrix(data, distance) {\n  var distanceMatrix = new Array(data.length);\n\n  for (var i = 0; i < data.length; ++i) {\n    for (var j = i; j < data.length; ++j) {\n      if (!distanceMatrix[i]) {\n        distanceMatrix[i] = new Array(data.length);\n      }\n\n      if (!distanceMatrix[j]) {\n        distanceMatrix[j] = new Array(data.length);\n      }\n\n      var dist = distance(data[i], data[j]);\n      distanceMatrix[i][j] = dist;\n      distanceMatrix[j][i] = dist;\n    }\n  }\n\n  return distanceMatrix;\n}\n/**\n * Updates the cluster identifier based in the new data\n * @ignore\n * @param {Array<Array<number>>} data - the [x,y,z,...] points to cluster\n * @param {Array<Array<number>>} centers - the K centers in format [x,y,z,...]\n * @param {Array <number>} clusterID - the cluster identifier for each data dot\n * @param {function} distance - Distance function to use between the points\n * @return {Array} the cluster identifier for each data dot\n */\n\nexport function updateClusterID(data, centers, clusterID, distance) {\n  for (var i = 0; i < data.length; i++) {\n    clusterID[i] = nearestVector(centers, data[i], {\n      distanceFunction: distance\n    });\n  }\n\n  return clusterID;\n}\n/**\n * Update the center values based in the new configurations of the clusters\n * @ignore\n * @param {Array<Array<number>>} prevCenters - Centroids from the previous iteration\n * @param {Array <Array <number>>} data - the [x,y,z,...] points to cluster\n * @param {Array <number>} clusterID - the cluster identifier for each data dot\n * @param {number} K - Number of clusters\n * @return {Array} he K centers in format [x,y,z,...]\n */\n\nexport function updateCenters(prevCenters, data, clusterID, K) {\n  var nDim = data[0].length; // copy previous centers\n\n  var centers = new Array(K);\n  var centersLen = new Array(K);\n\n  for (var i = 0; i < K; i++) {\n    centers[i] = new Array(nDim);\n    centersLen[i] = 0;\n\n    for (var j = 0; j < nDim; j++) {\n      centers[i][j] = 0;\n    }\n  } // add the value for all dimensions of the point\n\n\n  for (var l = 0; l < data.length; l++) {\n    centersLen[clusterID[l]]++;\n\n    for (var dim = 0; dim < nDim; dim++) {\n      centers[clusterID[l]][dim] += data[l][dim];\n    }\n  } // divides by length\n\n\n  for (var id = 0; id < K; id++) {\n    for (var d = 0; d < nDim; d++) {\n      if (centersLen[id]) {\n        centers[id][d] /= centersLen[id];\n      } else {\n        centers[id][d] = prevCenters[id][d];\n      }\n    }\n  }\n\n  return centers;\n}\n/**\n * The centers have moved more than the tolerance value?\n * @ignore\n * @param {Array<Array<number>>} centers - the K centers in format [x,y,z,...]\n * @param {Array<Array<number>>} oldCenters - the K old centers in format [x,y,z,...]\n * @param {function} distanceFunction - Distance function to use between the points\n * @param {number} tolerance - Allowed distance for the centroids to move\n * @return {boolean}\n */\n\nexport function hasConverged(centers, oldCenters, distanceFunction, tolerance) {\n  for (var i = 0; i < centers.length; i++) {\n    if (distanceFunction(centers[i], oldCenters[i]) > tolerance) {\n      return false;\n    }\n  }\n\n  return true;\n}","import _classCallCheck from \"/home/philipp/git/cmu-isle/isle-dashboard/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/classCallCheck\";\nimport _createClass from \"/home/philipp/git/cmu-isle/isle-dashboard/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/createClass\";\nvar LOOP = 8;\nvar FLOAT_MUL = 1 / 16777216;\nvar sh1 = 15;\nvar sh2 = 18;\nvar sh3 = 11;\n\nfunction multiply_uint32(n, m) {\n  n >>>= 0;\n  m >>>= 0;\n  var nlo = n & 0xffff;\n  var nhi = n - nlo;\n  return (nhi * m >>> 0) + nlo * m >>> 0;\n}\n\nvar XSadd = /*#__PURE__*/function () {\n  function XSadd() {\n    var seed = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : Date.now();\n\n    _classCallCheck(this, XSadd);\n\n    this.state = new Uint32Array(4);\n    this.init(seed);\n    this.random = this.getFloat.bind(this);\n  }\n  /**\n   * Returns a 32-bit integer r (0 <= r < 2^32)\n   */\n\n\n  _createClass(XSadd, [{\n    key: \"getUint32\",\n    value: function getUint32() {\n      this.nextState();\n      return this.state[3] + this.state[2] >>> 0;\n    }\n    /**\n     * Returns a floating point number r (0.0 <= r < 1.0)\n     */\n\n  }, {\n    key: \"getFloat\",\n    value: function getFloat() {\n      return (this.getUint32() >>> 8) * FLOAT_MUL;\n    }\n  }, {\n    key: \"init\",\n    value: function init(seed) {\n      if (!Number.isInteger(seed)) {\n        throw new TypeError('seed must be an integer');\n      }\n\n      this.state[0] = seed;\n      this.state[1] = 0;\n      this.state[2] = 0;\n      this.state[3] = 0;\n\n      for (var i = 1; i < LOOP; i++) {\n        this.state[i & 3] ^= i + multiply_uint32(1812433253, this.state[i - 1 & 3] ^ this.state[i - 1 & 3] >>> 30 >>> 0) >>> 0;\n      }\n\n      this.periodCertification();\n\n      for (var _i = 0; _i < LOOP; _i++) {\n        this.nextState();\n      }\n    }\n  }, {\n    key: \"periodCertification\",\n    value: function periodCertification() {\n      if (this.state[0] === 0 && this.state[1] === 0 && this.state[2] === 0 && this.state[3] === 0) {\n        this.state[0] = 88; // X\n\n        this.state[1] = 83; // S\n\n        this.state[2] = 65; // A\n\n        this.state[3] = 68; // D\n      }\n    }\n  }, {\n    key: \"nextState\",\n    value: function nextState() {\n      var t = this.state[0];\n      t ^= t << sh1;\n      t ^= t >>> sh2;\n      t ^= this.state[3] << sh3;\n      this.state[0] = this.state[1];\n      this.state[1] = this.state[2];\n      this.state[2] = this.state[3];\n      this.state[3] = t;\n    }\n  }]);\n\n  return XSadd;\n}();\n\nexport { XSadd as default };","var PROB_TOLERANCE = 0.00000001;\n\nfunction randomChoice(values) {\n  var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n  var random = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : Math.random;\n  var _options$size = options.size,\n      size = _options$size === void 0 ? 1 : _options$size,\n      _options$replace = options.replace,\n      replace = _options$replace === void 0 ? false : _options$replace,\n      probabilities = options.probabilities;\n  var valuesArr;\n  var cumSum;\n\n  if (typeof values === 'number') {\n    valuesArr = getArray(values);\n  } else {\n    valuesArr = values.slice();\n  }\n\n  if (probabilities) {\n    if (!replace) {\n      throw new Error('choice with probabilities and no replacement is not implemented');\n    } // check input is sane\n\n\n    if (probabilities.length !== valuesArr.length) {\n      throw new Error('the length of probabilities option should be equal to the number of choices');\n    }\n\n    cumSum = [probabilities[0]];\n\n    for (var i = 1; i < probabilities.length; i++) {\n      cumSum[i] = cumSum[i - 1] + probabilities[i];\n    }\n\n    if (Math.abs(1 - cumSum[cumSum.length - 1]) > PROB_TOLERANCE) {\n      throw new Error(\"probabilities should sum to 1, but instead sums to \".concat(cumSum[cumSum.length - 1]));\n    }\n  }\n\n  if (replace === false && size > valuesArr.length) {\n    throw new Error('size option is too large');\n  }\n\n  var result = [];\n\n  for (var _i = 0; _i < size; _i++) {\n    var index = randomIndex(valuesArr.length, random, cumSum);\n    result.push(valuesArr[index]);\n\n    if (!replace) {\n      valuesArr.splice(index, 1);\n    }\n  }\n\n  return result;\n}\n\nfunction getArray(n) {\n  var arr = [];\n\n  for (var i = 0; i < n; i++) {\n    arr.push(i);\n  }\n\n  return arr;\n}\n\nfunction randomIndex(n, random, cumSum) {\n  var rand = random();\n\n  if (!cumSum) {\n    return Math.floor(rand * n);\n  } else {\n    var idx = 0;\n\n    while (rand > cumSum[idx]) {\n      idx++;\n    }\n\n    return idx;\n  }\n}\n\nexport default randomChoice;","import _classCallCheck from \"/home/philipp/git/cmu-isle/isle-dashboard/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/classCallCheck\";\nimport _createClass from \"/home/philipp/git/cmu-isle/isle-dashboard/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/createClass\";\n// tslint:disable-next-line\nimport XSAdd from 'ml-xsadd';\nimport _choice from './choice';\n/**\n * @classdesc Random class\n */\n\nvar Random = /*#__PURE__*/function () {\n  /**\n   * @param [seedOrRandom=Math.random] - Control the random number generator used by the Random class instance. Pass a random number generator function with a uniform distribution over the half-open interval [0, 1[. If seed will pass it to ml-xsadd to create a seeded random number generator. If undefined will use Math.random.\n   */\n  function Random() {\n    var seedOrRandom = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : Math.random;\n\n    _classCallCheck(this, Random);\n\n    if (typeof seedOrRandom === 'number') {\n      var xsadd = new XSAdd(seedOrRandom);\n      this.randomGenerator = xsadd.random;\n    } else {\n      this.randomGenerator = seedOrRandom;\n    }\n  }\n\n  _createClass(Random, [{\n    key: \"choice\",\n    value: function choice(values, options) {\n      if (typeof values === 'number') {\n        return _choice(values, options, this.randomGenerator);\n      }\n\n      return _choice(values, options, this.randomGenerator);\n    }\n    /**\n     * Draw a random number from a uniform distribution on [0,1)\n     * @return The random number\n     */\n\n  }, {\n    key: \"random\",\n    value: function random() {\n      return this.randomGenerator();\n    }\n    /**\n     * Draw a random integer from a uniform distribution on [low, high). If only low is specified, the number is drawn on [0, low)\n     * @param low - The lower bound of the uniform distribution interval.\n     * @param high - The higher bound of the uniform distribution interval.\n     */\n\n  }, {\n    key: \"randInt\",\n    value: function randInt(low, high) {\n      if (high === undefined) {\n        high = low;\n        low = 0;\n      }\n\n      return low + Math.floor(this.randomGenerator() * (high - low));\n    }\n    /**\n     * Draw several random number from a uniform distribution on [0, 1)\n     * @param size - The number of number to draw\n     * @return - The list of drawn numbers.\n     */\n\n  }, {\n    key: \"randomSample\",\n    value: function randomSample(size) {\n      var result = [];\n\n      for (var i = 0; i < size; i++) {\n        result.push(this.random());\n      }\n\n      return result;\n    }\n  }]);\n\n  return Random;\n}();\n\nexport { Random as default };","import Random from 'ml-random';\nimport { squaredEuclidean } from 'ml-distance-euclidean';\nimport { Matrix } from 'ml-matrix';\n/**\n * Choose K different random points from the original data\n * @ignore\n * @param {Array<Array<number>>} data - Points in the format to cluster [x,y,z,...]\n * @param {number} K - number of clusters\n * @param {number} seed - seed for random number generation\n * @return {Array<Array<number>>} - Initial random points\n */\n\nexport function random(data, K, seed) {\n  var random = new Random(seed);\n  return random.choice(data, {\n    size: K\n  });\n}\n/**\n * Chooses the most distant points to a first random pick\n * @ignore\n * @param {Array<Array<number>>} data - Points in the format to cluster [x,y,z,...]\n * @param {number} K - number of clusters\n * @param {Array<Array<number>>} distanceMatrix - matrix with the distance values\n * @param {number} seed - seed for random number generation\n * @return {Array<Array<number>>} - Initial random points\n */\n\nexport function mostDistant(data, K, distanceMatrix, seed) {\n  var random = new Random(seed);\n  var ans = new Array(K); // chooses a random point as initial cluster\n\n  ans[0] = Math.floor(random.random() * data.length);\n\n  if (K > 1) {\n    // chooses the more distant point\n    var maxDist = {\n      dist: -1,\n      index: -1\n    };\n\n    for (var l = 0; l < data.length; ++l) {\n      if (distanceMatrix[ans[0]][l] > maxDist.dist) {\n        maxDist.dist = distanceMatrix[ans[0]][l];\n        maxDist.index = l;\n      }\n    }\n\n    ans[1] = maxDist.index;\n\n    if (K > 2) {\n      // chooses the set of points that maximises the min distance\n      for (var k = 2; k < K; ++k) {\n        var center = {\n          dist: -1,\n          index: -1\n        };\n\n        for (var m = 0; m < data.length; ++m) {\n          // minimum distance to centers\n          var minDistCent = {\n            dist: Number.MAX_VALUE,\n            index: -1\n          };\n\n          for (var n = 0; n < k; ++n) {\n            if (distanceMatrix[n][m] < minDistCent.dist && ans.indexOf(m) === -1) {\n              minDistCent = {\n                dist: distanceMatrix[n][m],\n                index: m\n              };\n            }\n          }\n\n          if (minDistCent.dist !== Number.MAX_VALUE && minDistCent.dist > center.dist) {\n            center = Object.assign({}, minDistCent);\n          }\n        }\n\n        ans[k] = center.index;\n      }\n    }\n  }\n\n  return ans.map(function (index) {\n    return data[index];\n  });\n} // Implementation inspired from scikit\n\nexport function kmeanspp(X, K) {\n  var options = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};\n  X = new Matrix(X);\n  var nSamples = X.rows;\n  var random = new Random(options.seed); // Set the number of trials\n\n  var centers = [];\n  var localTrials = options.localTrials || 2 + Math.floor(Math.log(K)); // Pick the first center at random from the dataset\n\n  var firstCenterIdx = random.randInt(nSamples);\n  centers.push(X.getRow(firstCenterIdx)); // Init closest distances\n\n  var closestDistSquared = new Matrix(1, X.rows);\n\n  for (var i = 0; i < X.rows; i++) {\n    closestDistSquared.set(0, i, squaredEuclidean(X.getRow(i), centers[0]));\n  }\n\n  var cumSumClosestDistSquared = [cumSum(closestDistSquared.getRow(0))];\n  var factor = 1 / cumSumClosestDistSquared[0][nSamples - 1];\n  var probabilities = Matrix.mul(closestDistSquared, factor); // Iterate over the remaining centers\n\n  for (var _i = 1; _i < K; _i++) {\n    var candidateIdx = random.choice(nSamples, {\n      replace: true,\n      size: localTrials,\n      probabilities: probabilities[0]\n    });\n    var candidates = X.selection(candidateIdx, range(X.columns));\n    var distanceToCandidates = euclideanDistances(candidates, X);\n    var bestCandidate = void 0;\n    var bestPot = void 0;\n    var bestDistSquared = void 0;\n\n    for (var j = 0; j < localTrials; j++) {\n      var newDistSquared = Matrix.min(closestDistSquared, [distanceToCandidates.getRow(j)]);\n      var newPot = newDistSquared.sum();\n\n      if (bestCandidate === undefined || newPot < bestPot) {\n        bestCandidate = candidateIdx[j];\n        bestPot = newPot;\n        bestDistSquared = newDistSquared;\n      }\n    }\n\n    centers[_i] = X.getRow(bestCandidate);\n    closestDistSquared = bestDistSquared;\n    cumSumClosestDistSquared = [cumSum(closestDistSquared.getRow(0))];\n    probabilities = Matrix.mul(closestDistSquared, 1 / cumSumClosestDistSquared[0][nSamples - 1]);\n  }\n\n  return centers;\n}\n\nfunction euclideanDistances(A, B) {\n  var result = new Matrix(A.rows, B.rows);\n\n  for (var i = 0; i < A.rows; i++) {\n    for (var j = 0; j < B.rows; j++) {\n      result.set(i, j, squaredEuclidean(A.getRow(i), B.getRow(j)));\n    }\n  }\n\n  return result;\n}\n\nfunction range(l) {\n  var r = [];\n\n  for (var i = 0; i < l; i++) {\n    r.push(i);\n  }\n\n  return r;\n}\n\nfunction cumSum(arr) {\n  var cumSum = [arr[0]];\n\n  for (var i = 1; i < arr.length; i++) {\n    cumSum[i] = cumSum[i - 1] + arr[i];\n  }\n\n  return cumSum;\n}","import _classCallCheck from \"/home/philipp/git/cmu-isle/isle-dashboard/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/classCallCheck\";\nimport _createClass from \"/home/philipp/git/cmu-isle/isle-dashboard/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/createClass\";\nimport { updateClusterID } from './utils';\nvar distanceSymbol = Symbol('distance');\n\nvar KMeansResult = /*#__PURE__*/function () {\n  /**\n   * Result of the kmeans algorithm\n   * @param {Array<number>} clusters - the cluster identifier for each data dot\n   * @param {Array<Array<object>>} centroids - the K centers in format [x,y,z,...], the error and size of the cluster\n   * @param {boolean} converged - Converge criteria satisfied\n   * @param {number} iterations - Current number of iterations\n   * @param {function} distance - (*Private*) Distance function to use between the points\n   * @constructor\n   */\n  function KMeansResult(clusters, centroids, converged, iterations, distance) {\n    _classCallCheck(this, KMeansResult);\n\n    this.clusters = clusters;\n    this.centroids = centroids;\n    this.converged = converged;\n    this.iterations = iterations;\n    this[distanceSymbol] = distance;\n  }\n  /**\n   * Allows to compute for a new array of points their cluster id\n   * @param {Array<Array<number>>} data - the [x,y,z,...] points to cluster\n   * @return {Array<number>} - cluster id for each point\n   */\n\n\n  _createClass(KMeansResult, [{\n    key: \"nearest\",\n    value: function nearest(data) {\n      var clusterID = new Array(data.length);\n      var centroids = this.centroids.map(function (centroid) {\n        return centroid.centroid;\n      });\n      return updateClusterID(data, centroids, clusterID, this[distanceSymbol]);\n    }\n    /**\n     * Returns a KMeansResult with the error and size of the cluster\n     * @ignore\n     * @param {Array<Array<number>>} data - the [x,y,z,...] points to cluster\n     * @return {KMeansResult}\n     */\n\n  }, {\n    key: \"computeInformation\",\n    value: function computeInformation(data) {\n      var enrichedCentroids = this.centroids.map(function (centroid) {\n        return {\n          centroid: centroid,\n          error: 0,\n          size: 0\n        };\n      });\n\n      for (var i = 0; i < data.length; i++) {\n        enrichedCentroids[this.clusters[i]].error += this[distanceSymbol](data[i], this.centroids[this.clusters[i]]);\n        enrichedCentroids[this.clusters[i]].size++;\n      }\n\n      for (var j = 0; j < this.centroids.length; j++) {\n        if (enrichedCentroids[j].size) {\n          enrichedCentroids[j].error /= enrichedCentroids[j].size;\n        } else {\n          enrichedCentroids[j].error = null;\n        }\n      }\n\n      return new KMeansResult(this.clusters, enrichedCentroids, this.converged, this.iterations, this[distanceSymbol]);\n    }\n  }]);\n\n  return KMeansResult;\n}();\n\nexport { KMeansResult as default };","import _regeneratorRuntime from \"/home/philipp/git/cmu-isle/isle-dashboard/node_modules/babel-preset-react-app/node_modules/@babel/runtime/regenerator\";\n\nvar _marked = /*#__PURE__*/_regeneratorRuntime.mark(kmeansGenerator);\n\nimport { squaredEuclidean } from 'ml-distance-euclidean';\nimport { updateClusterID, updateCenters, hasConverged, calculateDistanceMatrix } from './utils';\nimport { mostDistant, random, kmeanspp } from './initialization';\nimport KMeansResult from './KMeansResult';\nvar defaultOptions = {\n  maxIterations: 100,\n  tolerance: 1e-6,\n  withIterations: false,\n  initialization: 'kmeans++',\n  distanceFunction: squaredEuclidean\n};\n/**\n * Each step operation for kmeans\n * @ignore\n * @param {Array<Array<number>>} centers - K centers in format [x,y,z,...]\n * @param {Array<Array<number>>} data - Points [x,y,z,...] to cluster\n * @param {Array<number>} clusterID - Cluster identifier for each data dot\n * @param {number} K - Number of clusters\n * @param {object} [options] - Option object\n * @param {number} iterations - Current number of iterations\n * @return {KMeansResult}\n */\n\nfunction step(centers, data, clusterID, K, options, iterations) {\n  clusterID = updateClusterID(data, centers, clusterID, options.distanceFunction);\n  var newCenters = updateCenters(centers, data, clusterID, K);\n  var converged = hasConverged(newCenters, centers, options.distanceFunction, options.tolerance);\n  return new KMeansResult(clusterID, newCenters, converged, iterations, options.distanceFunction);\n}\n/**\n * Generator version for the algorithm\n * @ignore\n * @param {Array<Array<number>>} centers - K centers in format [x,y,z,...]\n * @param {Array<Array<number>>} data - Points [x,y,z,...] to cluster\n * @param {Array<number>} clusterID - Cluster identifier for each data dot\n * @param {number} K - Number of clusters\n * @param {object} [options] - Option object\n */\n\n\nfunction kmeansGenerator(centers, data, clusterID, K, options) {\n  var converged, stepNumber, stepResult;\n  return _regeneratorRuntime.wrap(function kmeansGenerator$(_context) {\n    while (1) {\n      switch (_context.prev = _context.next) {\n        case 0:\n          converged = false;\n          stepNumber = 0;\n\n        case 2:\n          if (!(!converged && stepNumber < options.maxIterations)) {\n            _context.next = 10;\n            break;\n          }\n\n          stepResult = step(centers, data, clusterID, K, options, ++stepNumber);\n          _context.next = 6;\n          return stepResult.computeInformation(data);\n\n        case 6:\n          converged = stepResult.converged;\n          centers = stepResult.centroids;\n          _context.next = 2;\n          break;\n\n        case 10:\n        case \"end\":\n          return _context.stop();\n      }\n    }\n  }, _marked);\n}\n/**\n * K-means algorithm\n * @param {Array<Array<number>>} data - Points in the format to cluster [x,y,z,...]\n * @param {number} K - Number of clusters\n * @param {object} [options] - Option object\n * @param {number} [options.maxIterations = 100] - Maximum of iterations allowed\n * @param {number} [options.tolerance = 1e-6] - Error tolerance\n * @param {boolean} [options.withIterations = false] - Store clusters and centroids for each iteration\n * @param {function} [options.distanceFunction = squaredDistance] - Distance function to use between the points\n * @param {number} [options.seed] - Seed for random initialization.\n * @param {string|Array<Array<number>>} [options.initialization = 'kmeans++'] - K centers in format [x,y,z,...] or a method for initialize the data:\n *  * You can either specify your custom start centroids, or select one of the following initialization method:\n *  * `'kmeans++'` will use the kmeans++ method as described by http://ilpubs.stanford.edu:8090/778/1/2006-13.pdf\n *  * `'random'` will choose K random different values.\n *  * `'mostDistant'` will choose the more distant points to a first random pick\n * @return {KMeansResult} - Cluster identifier for each data dot and centroids with the following fields:\n *  * `'clusters'`: Array of indexes for the clusters.\n *  * `'centroids'`: Array with the resulting centroids.\n *  * `'iterations'`: Number of iterations that took to converge\n */\n\n\nexport default function kmeans(data, K, options) {\n  options = Object.assign({}, defaultOptions, options);\n\n  if (K <= 0 || K > data.length || !Number.isInteger(K)) {\n    throw new Error('K should be a positive integer smaller than the number of points');\n  }\n\n  var centers;\n\n  if (Array.isArray(options.initialization)) {\n    if (options.initialization.length !== K) {\n      throw new Error('The initial centers should have the same length as K');\n    } else {\n      centers = options.initialization;\n    }\n  } else {\n    switch (options.initialization) {\n      case 'kmeans++':\n        centers = kmeanspp(data, K, options);\n        break;\n\n      case 'random':\n        centers = random(data, K, options.seed);\n        break;\n\n      case 'mostDistant':\n        centers = mostDistant(data, K, calculateDistanceMatrix(data, options.distanceFunction), options.seed);\n        break;\n\n      default:\n        throw new Error(\"Unknown initialization method: \\\"\".concat(options.initialization, \"\\\"\"));\n    }\n  } // infinite loop until convergence\n\n\n  if (options.maxIterations === 0) {\n    options.maxIterations = Number.MAX_VALUE;\n  }\n\n  var clusterID = new Array(data.length);\n\n  if (options.withIterations) {\n    return kmeansGenerator(centers, data, clusterID, K, options);\n  } else {\n    var converged = false;\n    var stepNumber = 0;\n    var stepResult;\n\n    while (!converged && stepNumber < options.maxIterations) {\n      stepResult = step(centers, data, clusterID, K, options, ++stepNumber);\n      converged = stepResult.converged;\n      centers = stepResult.centroids;\n    }\n\n    return stepResult.computeInformation(data);\n  }\n}","// MODULES //\n\nimport React, { Component } from 'react';\nimport PropTypes from 'prop-types';\nimport { withTranslation } from 'react-i18next';\nimport kmeans from 'ml-kmeans';\nimport Alert from 'react-bootstrap/Alert';\nimport hasOwnProp from '@stdlib/assert/has-own-property';\nimport { isPrimitive as isNumber } from '@stdlib/assert/is-number';\nimport isnan from '@stdlib/assert/is-nan';\nimport Table from '@isle-project/components/table';\nimport { addResources } from '@isle-project/locales';\n\n\n// VARIABLES //\n\naddResources( 'StatisticalModels' );\n\n\n// FUNCTIONS //\n\nfunction isNonMissingNumber( x ) {\n\treturn isNumber( x ) && !isnan( x );\n}\n\nconst summaryTable = ( variables, centroids, t ) => {\n\treturn (\n\t\t<Table bordered size=\"sm\">\n\t\t\t<thead>\n\t\t\t\t<tr>\n\t\t\t\t\t<th>{t('cluster')}</th>\n\t\t\t\t\t{centroids.map( ( _, i ) => <th key={i} >{i+1}</th>)}\n\t\t\t\t</tr>\n\t\t\t</thead>\n\t\t\t<tbody>\n\t\t\t\t{variables.map( ( name, idx ) => {\n\t\t\t\t\treturn (\n\t\t\t\t\t\t<tr key={idx} >\n\t\t\t\t\t\t\t<th>{name}</th>\n\t\t\t\t\t\t\t{centroids.map( ( x, i ) => <td key={i} >{x.centroid[ idx ].toFixed( 4 )}</td>)}\n\t\t\t\t\t\t</tr>\n\t\t\t\t\t);\n\t\t\t\t})}\n\t\t\t</tbody>\n\t\t\t<tbody>\n\t\t\t\t<tr>\n\t\t\t\t\t<th>{t('size')}</th>\n\t\t\t\t\t{centroids.map( ( x, i ) => <th key={i} >{x.size}</th>)}\n\t\t\t\t</tr>\n\t\t\t</tbody>\n\t\t</Table>\n\t);\n};\n\nconst fitModel = ({ K, variables, data, initialization }) => {\n\tif ( !data || !variables || !K || !initialization ) {\n\t\treturn null;\n\t}\n\tconst matrix = [];\n\tif ( !hasOwnProp( data, variables[ 0 ] ) ) {\n\t\treturn null;\n\t}\n\tconst n = data[ variables[ 0 ] ].length;\n\tfor ( let i = 0; i < n; i++ ) {\n\t\tconst row = [];\n\t\tlet missing = false;\n\t\tfor ( let j = 0; j < variables.length; j++ ) {\n\t\t\tif ( !hasOwnProp( data, variables[ j ] ) ) {\n\t\t\t\treturn null;\n\t\t\t}\n\t\t\tconst val = data[ variables[ j ] ][ i ];\n\t\t\tif ( isNonMissingNumber( val ) ) {\n\t\t\t\trow.push( val );\n\t\t\t} else {\n\t\t\t\tmissing = true;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tif ( !missing ) {\n\t\t\tmatrix.push( row );\n\t\t}\n\t}\n\ttry {\n\t\tconst result = kmeans( matrix, K, {\n\t\t\tinitialization\n\t\t});\n\t\treturn result;\n\t} catch ( _ ) {\n\t\treturn null;\n\t}\n};\n\n\n// MAIN //\n\n/**\n* K-means clustering.\n*\n* @property {Object} data - object of value arrays\n* @property {Array<string>} variables - names of variables used for clustering\n* @property {string} initialization - initialization method (`kmeans++`, `random`, or `mostDistant`)\n* @property {number} K - number of clusters\n* @property {Function} onResult - callback invoked with model object\n*/\nclass KMeans extends Component {\n\tconstructor( props ) {\n\t\tsuper( props );\n\t\tconst { K, variables, data, initialization } = props;\n\t\tconst result = fitModel({ K, variables, data, initialization });\n\t\tthis.state = {\n\t\t\tresult,\n\t\t\t...props\n\t\t};\n\t\tif ( result ) {\n\t\t\tprops.onResult( result );\n\t\t}\n\t}\n\n\tstatic getDerivedStateFromProps( nextProps, prevState ) {\n\t\tif (\n\t\t\tnextProps.data !== prevState.data ||\n\t\t\tnextProps.variables !== prevState.variables ||\n\t\t\tnextProps.K !== prevState.K ||\n\t\t\tnextProps.initialization !== prevState.initialization\n\t\t) {\n\t\t\tconst { K, variables, data, initialization } = nextProps;\n\t\t\tconst result = fitModel({ K, variables, data, initialization });\n\t\t\tnextProps.onResult( result );\n\t\t\tconst newState = {\n\t\t\t\tresult,\n\t\t\t\t...nextProps\n\t\t\t};\n\t\t\treturn newState;\n\t\t}\n\t\treturn null;\n\t}\n\n\trender() {\n\t\tconst { result } = this.state;\n\t\tconst { t, variables } = this.props;\n\t\tif ( !result ) {\n\t\t\treturn <Alert variant=\"danger\">{t('missing-attributes')}</Alert>;\n\t\t}\n\t\treturn (\n\t\t\t<div style={{ overflowX: 'auto', width: '100%' }}>\n\t\t\t\t<span className=\"title\" >{t('kmeans-summary')}</span>\n\t\t\t\t<p>{result.converged ? t('algorithm-converged', { n: result.iterations }) : t('algorithm-not-converged', { n: result.iterations })}</p>\n\t\t\t\t{summaryTable( variables, result.centroid, t )}\n\t\t\t</div>\n\t\t);\n\t}\n}\n\n\n// PROPERTIES //\n\nKMeans.defaultProps = {\n\tK: 3,\n\tinitialization: 'kmeans++',\n\tonResult() {}\n};\n\nKMeans.propTypes = {\n\tdata: PropTypes.object.isRequired,\n\tvariables: PropTypes.arrayOf( PropTypes.string ).isRequired,\n\tK: PropTypes.number,\n\tinitialization: PropTypes.oneOf([ 'kmeans++', 'random', 'mostDistant' ]),\n\tonResult: PropTypes.func\n};\n\n\n// EXPORTS //\n\nexport default withTranslation( 'StatisticalModels' )( KMeans );\n"],"sourceRoot":""}