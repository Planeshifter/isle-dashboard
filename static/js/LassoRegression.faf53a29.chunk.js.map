{"version":3,"sources":["../node_modules/@stdlib/stdlib/lib/node_modules/@stdlib/assert/is-array-array/lib/index.js","../node_modules/@babel/runtime/helpers/esm/readOnlyError.js","../node_modules/@stdlib/stdlib/lib/node_modules/@stdlib/assert/is-array-array/lib/main.js","../node_modules/@isle-project/utils/mmult/index.js","../node_modules/@isle-project/utils/transpose/index.js","../node_modules/@stdlib/stdlib/lib/node_modules/@stdlib/utils/define-nonenumerable-property/lib/index.js","../node_modules/@stdlib/stdlib/lib/node_modules/@stdlib/utils/define-nonenumerable-property/lib/main.js","../node_modules/@isle-project/utils/multiply/index.js","../node_modules/@isle-project/utils/zscore/index.js","../node_modules/@isle-project/utils/divide/index.js","../node_modules/@isle-project/components/models/lasso-regression/dotm.js","../node_modules/@isle-project/components/models/lasso-regression/dotv.js","../node_modules/@isle-project/components/models/lasso-regression/soft_thresholding.js","../node_modules/@isle-project/components/models/lasso-regression/lasso.js","../node_modules/@isle-project/components/models/lasso-regression/main.js","../node_modules/@isle-project/utils/subtract/index.js"],"names":["isArrayArray","module","exports","_readOnlyError","name","TypeError","arrayfun","mmult","A","b","n","shape","p","ret","Float64Array","i","sum","j","get","matrix","ctor","transpose","X","strides","offset","order","_buffer","setNonEnumerableProperty","defineProperty","obj","prop","value","multiply","arr","x","isArr","isArrayLike","isNumber","len","length","out","Array","Error","zScore","demean","scale","avg","mean","sd","stdev","slice","divide","opts","dotm","y","nRows","xVal","yVal","dotv","softThresholding","t","debug","logger","PRECISION","mget","LassoFit","lambda","this","N","beta","betast","active","incrspace","nonactive","presid","init","iteration","iterate","prototype","testKKT","ymxb","subtract","G","abs","sign","testActiveSet","changed","residuals","predict","jVal","xj","push","splice","converged","rval","k","set","betaOld","betaNew","ndarray","fitted","lasso","isMatrixLike","addResources","COUNTER","designMatrix","data","quantitative","intercept","isArray","predictors","hash","standardized","categoricalStats","nobs","contains","values","counts","countBy","identity","categories","objectKeys","label","mu","sigma","sqrt","row","val","fitModel","yvalues","result","LASSO","coefSum","pred","_","LassoRegression","props","state","onPredict","style","overflowX","width","className","toFixed","counter","bordered","size","map","idx","key","Number","summaryTable","tooltip","Button","variant","onClick","handlePredict","Alert","nextProps","prevState","Component","defaultProps","withTranslation"],"mappings":"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","file":"static/js/LassoRegression.faf53a29.chunk.js","sourcesContent":["/**\n* @license Apache-2.0\n*\n* Copyright (c) 2018 The Stdlib Authors.\n*\n* Licensed under the Apache License, Version 2.0 (the \"License\");\n* you may not use this file except in compliance with the License.\n* You may obtain a copy of the License at\n*\n*    http://www.apache.org/licenses/LICENSE-2.0\n*\n* Unless required by applicable law or agreed to in writing, software\n* distributed under the License is distributed on an \"AS IS\" BASIS,\n* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n* See the License for the specific language governing permissions and\n* limitations under the License.\n*/\n'use strict';\n/**\n* Test if a value is an array of arrays.\n*\n* @module @stdlib/assert/is-array-array\n*\n* @example\n* var isArrayArray = require( '@stdlib/assert/is-array-array' );\n*\n* var bool = isArrayArray( [ [], [] ] );\n* // returns true\n*\n* bool = isArrayArray( [ {}, {} ] );\n* // returns false\n*\n* bool = isArrayArray( [] );\n* // returns false\n*/\n// MODULES //\n\nvar isArrayArray = require('./main.js'); // EXPORTS //\n\n\nmodule.exports = isArrayArray;","export default function _readOnlyError(name) {\n  throw new TypeError(\"\\\"\" + name + \"\\\" is read-only\");\n}","/**\n* @license Apache-2.0\n*\n* Copyright (c) 2018 The Stdlib Authors.\n*\n* Licensed under the Apache License, Version 2.0 (the \"License\");\n* you may not use this file except in compliance with the License.\n* You may obtain a copy of the License at\n*\n*    http://www.apache.org/licenses/LICENSE-2.0\n*\n* Unless required by applicable law or agreed to in writing, software\n* distributed under the License is distributed on an \"AS IS\" BASIS,\n* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n* See the License for the specific language governing permissions and\n* limitations under the License.\n*/\n'use strict'; // MODULES //\n\nvar arrayfun = require('@stdlib/assert/tools/array-function');\n\nvar isArray = require('@stdlib/assert/is-array'); // MAIN //\n\n/**\n* Tests if a value is an array of arrays.\n*\n* @name isArrayArray\n* @type {Function}\n* @param {*} value - value to test\n* @returns {boolean} boolean indicating whether a value is an array of arrays\n*\n* @example\n* var bool = isArrayArray( [ [], [] ] );\n* // returns true\n*\n* bool = isArrayArray( [ {}, {} ] );\n* // returns false\n*\n* bool = isArrayArray( [] );\n* // returns false\n*/\n\n\nvar isArrayArray = arrayfun(isArray); // EXPORTS //\n\nmodule.exports = isArrayArray;","/**\n* Computes a matrix product of a n x p matrix and a column vector of length p.\n*\n* @param {Matrix} A - n x p matrix\n* @param {Array} b - p x 1 column vector\n* @returns {Array} result of matrix multiplication\n*/\nfunction mmult( A, b ) {\n\tconst n = A.shape[ 0 ];\n\tconst p = A.shape[ 1 ];\n\n\tlet ret = new Float64Array( n );\n\tfor ( let i = 0; i < n; i++ ) {\n\t\t\tlet sum = 0;\n\t\t\tfor ( let j = 0; j < p; j++ ) {\n\t\t\t\tsum += A.get( i, j ) * b[ j ];\n\t\t\t}\n\t\t\tret[ i ] = sum;\n\t}\n\treturn ret;\n}\n\n\n// EXPORTS //\n\nexport default mmult;\n","/**\n* Copyright (C) 2020-present The ISLE Authors\n*\n* The isle-dashboard program is free software: you can redistribute it and/or modify\n* it under the terms of the GNU Affero General Public License as\n* published by the Free Software Foundation, either version 3 of the\n* License, or (at your option) any later version.\n*\n* This program is distributed in the hope that it will be useful,\n* but WITHOUT ANY WARRANTY; without even the implied warranty of\n* MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n* GNU Affero General Public License for more details.\n*\n* You should have received a copy of the GNU Affero General Public License\n* along with this program.  If not, see <https://www.gnu.org/licenses/>.\n*/\n\n// MODULES //\n\nimport ctor from '@stdlib/ndarray/ctor';\n\n\n// VARIABLES //\n\nconst matrix = ctor( 'float64', 2 );\n\n\n// MAIN //\n\n/**\n* Transposes a matrix.\n*\n* @param {Matrix} X - input matrix (2d `ndarray`)\n* @returns matrix transpose\n*/\nconst transpose = ( X ) => {\n\tconst shape = [ X.shape[ 1 ], X.shape[ 0 ] ];\n\tconst strides = [ X.strides[ 1 ], X.strides[ 0 ] ];\n\tconst offset = X.offset;\n\tconst order = X.order;\n\treturn matrix( X._buffer, shape, strides, offset, order );\n};\n\n\n// EXPORTS //\n\nexport default transpose;\n","/**\n* @license Apache-2.0\n*\n* Copyright (c) 2018 The Stdlib Authors.\n*\n* Licensed under the Apache License, Version 2.0 (the \"License\");\n* you may not use this file except in compliance with the License.\n* You may obtain a copy of the License at\n*\n*    http://www.apache.org/licenses/LICENSE-2.0\n*\n* Unless required by applicable law or agreed to in writing, software\n* distributed under the License is distributed on an \"AS IS\" BASIS,\n* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n* See the License for the specific language governing permissions and\n* limitations under the License.\n*/\n'use strict';\n/**\n* Define a non-enumerable property.\n*\n* @module @stdlib/utils/define-nonenumerable-property\n*\n* @example\n* var objectKeys = require( '@stdlib/utils/keys' );\n* var setNonEnumerableProperty = require( '@stdlib/utils/define-nonenumerable-property' );\n*\n* var obj = {};\n*\n* setNonEnumerableProperty( obj, 'foo', 'bar' );\n*\n* var v = obj.foo;\n* // returns 'bar'\n*\n* var keys = objectKeys( obj );\n* // returns []\n*/\n// MODULES //\n\nvar setNonEnumerableProperty = require('./main.js'); // EXPORTS //\n\n\nmodule.exports = setNonEnumerableProperty;","/**\n* @license Apache-2.0\n*\n* Copyright (c) 2018 The Stdlib Authors.\n*\n* Licensed under the Apache License, Version 2.0 (the \"License\");\n* you may not use this file except in compliance with the License.\n* You may obtain a copy of the License at\n*\n*    http://www.apache.org/licenses/LICENSE-2.0\n*\n* Unless required by applicable law or agreed to in writing, software\n* distributed under the License is distributed on an \"AS IS\" BASIS,\n* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n* See the License for the specific language governing permissions and\n* limitations under the License.\n*/\n'use strict'; // MODULES //\n\nvar defineProperty = require('@stdlib/utils/define-property'); // MAIN //\n\n/**\n* Defines a non-enumerable property.\n*\n* @param {Object} obj - object on which to define the property\n* @param {(string|symbol)} prop - property name\n* @param {*} value - value to set\n*\n* @example\n* var objectKeys = require( '@stdlib/utils/keys' );\n*\n* var obj = {};\n*\n* setNonEnumerableProperty( obj, 'foo', 'bar' );\n*\n* var v = obj.foo;\n* // returns 'bar'\n*\n* var keys = objectKeys( obj );\n* // returns []\n*/\n\n\nfunction setNonEnumerableProperty(obj, prop, value) {\n  defineProperty(obj, prop, {\n    'configurable': true,\n    'enumerable': false,\n    'writable': true,\n    'value': value\n  });\n} // EXPORTS //\n\n\nmodule.exports = setNonEnumerableProperty;","// MODULES //\n\nimport isArrayLike from '@stdlib/assert/is-array-like';\nimport { isPrimitive as isNumber } from '@stdlib/assert/is-number';\n\n\n// MAIN //\n\n/**\n* Computes an element-wise multiplication.\n*\n* @param {NumberArray} arr - input array\n* @param {(NumberArray|number)} x - either an array of equal length or a scalar\n* @returns {NumberArray} output array\n*/\nfunction multiply( arr, x ) {\n\tconst isArr = isArrayLike( x );\n\tif ( !isArrayLike( arr ) ) {\n\t\tthrow new TypeError( 'invalid input argument. Must provide an array. Value: `' + arr + '`.' );\n\t}\n\tif ( !isArr && !isNumber( x ) ) {\n\t\tthrow new TypeError( 'invalid input argument. Second argument must either be an array or number primitive. Value: `' + x + '`.' );\n\t}\n\tconst len = arr.length;\n\tconst out = new Array( len );\n\n\t// Case 1: x is an array\n\tif ( isArr ) {\n\t\tif ( len !== x.length ) {\n\t\t\tthrow new Error( 'invalid input argument. Array to be multiplied must have a length equal to that of the input array.' );\n\t\t}\n\t\tfor ( let i = 0; i < len; i++ ) {\n\t\t\tout[ i ] = arr[ i ] * x[ i ];\n\t\t}\n\t}\n\t// Case 2: scalar\n\telse {\n\t\tfor ( let i = 0; i < len; i++ ) {\n\t\t\tout[ i ] = arr[ i ] * x;\n\t\t}\n\t}\n\treturn out;\n}\n\n\n// EXPORTS //\n\nexport default multiply;\n","/**\n* Copyright (C) 2020-present The ISLE Authors\n*\n* The isle-dashboard program is free software: you can redistribute it and/or modify\n* it under the terms of the GNU Affero General Public License as\n* published by the Free Software Foundation, either version 3 of the\n* License, or (at your option) any later version.\n*\n* This program is distributed in the hope that it will be useful,\n* but WITHOUT ANY WARRANTY; without even the implied warranty of\n* MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n* GNU Affero General Public License for more details.\n*\n* You should have received a copy of the GNU Affero General Public License\n* along with this program.  If not, see <https://www.gnu.org/licenses/>.\n*/\n\n// MODULES //\n\nimport mean from '@isle-project/utils/statistic/mean';\nimport stdev from '@isle-project/utils/statistic/stdev';\nimport setNonEnumerableProperty from '@stdlib/utils/define-nonenumerable-property';\n\n\n// MAIN //\n\n/**\n* Standardizes elements in input array.\n*\n* @param {Array} x - input array\n* @param {boolean} demean - controls whether the mean should be subtracted from the values\n* @param {boolean} scale - controls whether values should be divided by the standard deviation\n* @returns {Array} output array with added `mu` and `sigma` properties\n*/\nfunction zScore( x, demean = true, scale = true ) {\n\tconst avg = mean( x );\n\tconst sd = stdev( x );\n\tconst len = x.length;\n\n\tconst out = new Array( len );\n\tif ( demean ) {\n\t\tif ( scale ) {\n\t\t\tfor ( let i = 0; i < len; i++ ) {\n\t\t\t\tout[ i ] = ( x[ i ] - avg ) / sd;\n\t\t\t}\n\t\t} else {\n\t\t\tfor ( let i = 0; i < len; i++ ) {\n\t\t\t\tout[ i ] = ( x[ i ] - avg );\n\t\t\t}\n\t\t}\n\t}\n\telse if ( scale ) {\n\t\tfor ( let i = 0; i < len; i++ ) {\n\t\t\tout[ i ] = x[ i ] / sd;\n\t\t}\n\t}\n\telse {\n\t\tout = x.slice();\n\t}\n\tsetNonEnumerableProperty( out, 'mu', avg );\n\tsetNonEnumerableProperty( out, 'sigma', sd );\n\treturn out;\n}\n\n\n// EXPORTS //\n\nexport default zScore;\n","// MODULES //\n\nimport isArrayLike from '@stdlib/assert/is-array-like';\nimport { isPrimitive as isNumber } from '@stdlib/assert/is-number';\n\n\n// MAIN //\n\n/**\n* Computes an element-wise division.\n*\n* @param {NumberArray} arr - input array\n* @param {(NumberArray|number)} x - either an array of equal length or a scalar\n* @returns {NumberArray} output array\n*/\nfunction divide( arr, x, opts ) {\n\tconst isArr = isArrayLike( x );\n\tif ( !isArrayLike( arr ) ) {\n\t\tthrow new TypeError( 'invalid input argument. Must provide an array. Value: `' + arr + '`.' );\n\t}\n\tif ( !isArr && !isNumber( x ) ) {\n\t\tthrow new TypeError( 'invalid input argument. Second argument must either be an array or number primitive. Value: `' + x + '`.' );\n\t}\n\tconst len = arr.length;\n\tconst out = new Array( len );\n\n\t// Case 1: x is an array\n\tif ( isArr ) {\n\t\tif ( len !== x.length ) {\n\t\t\tthrow new Error( 'invalid input argument. Array to be divided must have a length equal to that of the input array.' );\n\t\t}\n\t\tfor ( let i = 0; i < len; i++ ) {\n\t\t\tout[ i ] = arr[ i ] / x[ i ];\n\t\t}\n\t}\n\t// Case 2: scalar\n\telse {\n\t\tfor ( let i = 0; i < len; i++ ) {\n\t\t\tout[ i ] = arr[ i ] / x;\n\t\t}\n\t}\n\treturn out;\n}\n\n\n// EXPORTS //\n\nexport default divide;\n","// MAIN //\n\n/**\n* Calculates the dot product between j-th column vectors of the two input matrices skipping zero elements.\n*\n* @param {Matrix} x - first input matrix\n* @param {Matrix} y - second input matrix\n* @param {number} j - column index\n* @returns {number} dot product value\n*/\nfunction dotm( x, y, j ) {\n\tlet ret = 0.0;\n\tconst nRows = x.shape[ 0 ];\n\tfor ( let i = 0; i < nRows; i++ ) {\n\t\tconst xVal = x.get( i, j );\n\t\tconst yVal = y.get( i, j );\n\t\tif ( xVal !== 0 && yVal !== 0 ) {\n\t\t\tret += xVal * yVal;\n\t\t}\n\t}\n\treturn ret;\n}\n\n\n// EXPORTS //\n\nexport default dotm;\n","// MAIN //\n\n/**\n* Calculates the dot product between two arrays.\n*\n* @param {NumberArray} x - first vector\n* @param {NumberArray} y - second vector\n* @returns {number} dot product\n*/\nfunction dotv( x, y ) {\n\tconst len = x.length;\n\tlet sum = 0.0;\n\tfor ( let i = 0; i < len; i++ ) {\n\t\tsum += x[ i ] * y[ i ];\n\t}\n\treturn sum;\n}\n\n\n// EXPORTS //\n\nexport default dotv;\n","// MAIN //\n\n/**\n* Soft-thresholding operator.\n*\n* @param {number} x - input value\n* @param {number} t - threshold value\n* @returns {number} return value\n*/\nfunction softThresholding( x, t ) {\n\tif ( x > t ) {\n\t\treturn x - t;\n\t} else if ( x < -t ) {\n\t\treturn x + t;\n\t}\n\treturn 0;\n}\n\n\n// EXPORTS //\n\nexport default softThresholding;\n","// MODULES //\n\nimport logger from 'debug';\nimport incrspace from '@stdlib/math/utils/incrspace';\nimport sign from '@stdlib/math/base/special/signum';\nimport isArrayArray from '@stdlib/assert/is-array-array';\nimport isMatrixLike from '@stdlib/assert/is-matrix-like';\nimport ctor from '@stdlib/ndarray/ctor';\nimport ndarray from '@stdlib/ndarray/array';\nimport isNumber from '@stdlib/assert/is-number';\nimport isArrayLike from '@stdlib/assert/is-array-like';\nimport abs from '@stdlib/math/base/special/abs';\nimport mmult from '@isle-project/utils/mmult';\nimport transpose from '@isle-project/utils/transpose';\nimport subtract from '@isle-project/utils/subtract';\nimport divide from '@isle-project/utils/divide';\nimport dotm from './dotm.js';\nimport dotv from './dotv.js';\nimport softThresholding from './soft_thresholding.js';\n\n\n// VARIABLES //\n\nconst debug = logger( 'isle:lasso' );\nconst matrix = ctor( 'generic', 2 );\nconst PRECISION = 1e-9;\n\n\n// FUNCTIONS //\n\nconst mget = ( x, j ) => {\n\tconst out = new Float64Array( x.shape[ 0 ] );\n\tfor ( let i = 0; i < out.length; i++ ) {\n\t\tout[ i ] = x.get( i, j );\n\t}\n\treturn out;\n};\n\n\n// MAIN //\n\n/**\n* Lasso object to fit regression.\n*\n* @constructor\n* @returns {LassoFit} instance\n*/\nfunction LassoFit( y, x, lambda ) {\n\tthis.y = y;\n\tthis.x = x;\n\tthis.lambda = lambda;\n\n\tthis.N = x.shape[ 0 ];\n\tthis.p = x.shape[ 1 ];\n\n\t// Initialize model parameters to zero:\n\tthis.beta = new Float64Array( this.p );\n\tthis.betast = new Float64Array( this.p );\n\n\t// Initialize active set to all predictors:\n\tthis.active = incrspace( 0, this.beta.length, 1 );\n\tthis.nonactive = [];\n\n\t// Matrix holding partial residuals:\n\tthis.presid = matrix( new Float64Array( x._buffer.length ), x.shape, x.strides, x.offset, x.order );\n\n\tthis.init = () => {\n\t\tthis.iteration = 0;\n\t\tthis.iterate();\n\t};\n\tthis.init();\n}\n\n/**\n* Checks the Karush-Khun-Tucker (KKT) conditions for an optimal solution.\n*\n* @returns {boolean} returns true if optimal conditions are satisfied, false otherwise\n*/\nLassoFit.prototype.testKKT = function testKKT() {\n\tconst beta = this.beta;\n\tconst N = this.N;\n\tconst x = this.x;\n\tconst y = this.y;\n\n\tconst ymxb = subtract( y, mmult( x, beta ) );\n\tconst G = divide( mmult( transpose( x ), ymxb ), N );\n\tfor ( let i = 0; i < beta.length; i++ ) {\n\t\tif ( beta[ i ] === 0 ) {\n\t\t\tif ( abs( G[i] ) > this.lambda + PRECISION ) {\n\t\t\t\treturn false;\n\t\t\t}\n\t\t} else if ( beta[ i ] > 0 ) {\n\t\t\tif ( G[i] - this.lambda * sign( beta[i] ) > PRECISION ) {\n\t\t\t\treturn false;\n\t\t\t}\n\t\t}\n\t}\n\treturn true;\n};\n\n/**\n* Exclusion test for all predictors not in active set. If one or more predictors fail the test, they are included in the active set.\n*\n* @returns {boolean} returns true if active set was changed, false otherwise\n*/\nLassoFit.prototype.testActiveSet = function testActiveSet() {\n\tlet changed = false;\n\n\tconst { residuals } = this.predict( this.x );\n\n\t// See whether non-active variables all pass exclusion test:\n\tfor ( let j = 0; j < this.nonactive.length; j++ ) {\n\t\tconst jVal = this.nonactive[ j ];\n\t\tconst xj = mget( this.x, jVal );\n\t\tif ( abs( dotv( xj, residuals ) ) / this.N > this.lambda ) {\n\t\t\t// Test failed: include predictor in active set -> iterate again\n\t\t\tthis.active.push( jVal );\n\t\t\tthis.nonactive.splice( j, 1 );\n\t\t\tchanged = true;\n\t\t}\n\t}\n\tdebug( 'Active set changes...' );\n\treturn changed;\n};\n\n/**\n* Iterate over the active set of predictors and perform coordinate descent until convergence.\n*\n* @returns {void}\n*/\nLassoFit.prototype.iterate = function iterate() {\n\tconst N = this.N;\n\tconst p = this.p;\n\tconst x = this.x;\n\tconst y = this.y;\n\n\tthis.iteration += 1;\n\tif ( this.iteration > 10000 ) {\n\t\t// Break out after maximum number of iterations is reached...\n\t\treturn;\n\t}\n\n\tlet converged = true;\n\tfor ( let j = 0; j < this.active.length; j++ ) {\n\t\tconst jVal = this.active[ j ];\n\t\tfor ( let i = 0; i < N; i++ ) {\n\t\t\tconst rval = y[ i ];\n\t\t\tfor ( let k = 0; k < p; k++ ) {\n\t\t\t\trval -= ( jVal !== k ) ? x.get( i, k ) * this.beta[ k ] : 0;\n\t\t\t}\n\t\t\tthis.presid.set( i, jVal, rval );\n\t\t}\n\t\tthis.betast[ jVal ] = (1/N) * dotm( x, this.presid, jVal );\n\t\tconst betaOld = this.beta[ jVal ];\n\t\tconst betaNew = softThresholding( this.betast[ jVal ], this.lambda );\n\t\tif ( abs( betaNew - betaOld ) > PRECISION ) {\n\t\t\tconverged = false;\n\t\t}\n\t\tthis.beta[ jVal ] = betaNew;\n\t}\n\t// Recompute active set:\n\tfor ( let j = this.active.length - 1; j >= 0; j-- ) {\n\t\tconst jVal = this.active[ j ];\n\t\tif ( abs( this.beta[ jVal ] ) < PRECISION ) {\n\t\t\tthis.active.splice( j, 1 );\n\t\t\tthis.nonactive.push( jVal );\n\t\t}\n\t}\n\tif ( converged === false ) {\n\t\tthis.iterate();\n\t} else if ( this.testActiveSet() ) {\n\t\tthis.iterate();\n\t}\n};\n\n/**\n* Calculates the current model fitted values (yhat) and residuals (e = y - yhat).\n*\n* @returns {Object} fitted values and residuals\n*/\nLassoFit.prototype.predict = function predict( x ) {\n\tif ( isArrayArray( x ) ) {\n\t\tx = ndarray( x );\n\t}\n\tconst fitted = mmult( x, this.beta );\n\tconst residuals = new Array( this.N );\n\tfor ( let i = 0; i < this.N; i++ ) {\n\t\tresiduals[ i ] = this.y[ i ] - fitted[ i ];\n\t}\n\treturn { fitted, residuals };\n};\n\n\n// MAIN //\n\n/**\n* Fit lasso regression via coordinate descent.\n*\n* @param {Matrix|Array} x - design matrix\n* @param {NumberArray} y - response vector\n* @param {number} lambda - L1 penalty value\n* @returns {Object} regression model\n*/\nfunction lasso( x, y, lambda ) {\n\tif ( !isNumber ) {\n\t\tthrow new TypeError( 'invalid input argument. The third argument must be a number primitive. Value: `' + lambda + '`' );\n\t}\n\tif ( !isArrayLike( y ) ) {\n\t\tthrow new TypeError( 'invalid input argument. The second argument must be array-like. Value: `' + y + '`' );\n\t}\n\tif ( isArrayArray( x ) ) {\n\t\tx = ndarray( x );\n\t} else if ( !isMatrixLike( x ) ) {\n\t\tconst msg = 'invalid input argument. The first argument must be a matrix or an array-of-arrays. Value: `' + x + '`';\n\t\tthrow new TypeError( msg );\n\t}\n\treturn new LassoFit( y, x, lambda );\n}\n\n\n// EXPORTS //\n\nexport default lasso;\n","// MODULES //\n\nimport React, { Component } from 'react';\nimport PropTypes from 'prop-types';\nimport { withTranslation } from 'react-i18next';\nimport Alert from 'react-bootstrap/Alert';\nimport contains from '@stdlib/assert/contains';\nimport isArray from '@stdlib/assert/is-array';\nimport { isPrimitive as isNumber } from '@stdlib/assert/is-number';\nimport countBy from '@stdlib/utils/count-by';\nimport identity from '@stdlib/utils/identity-function';\nimport objectKeys from '@stdlib/utils/keys';\nimport sqrt from '@stdlib/math/base/special/sqrt';\nimport Button from 'react-bootstrap/Button';\nimport Tooltip from '@isle-project/components/tooltip';\nimport Table from '@isle-project/components/table';\nimport multiply from '@isle-project/utils/multiply';\nimport zScore from '@isle-project/utils/zscore';\nimport { addResources } from '@isle-project/locales';\nimport LASSO from './lasso.js';\n\n\n// VARIABLES //\n\naddResources( 'StatisticalModels' );\nlet COUNTER = 0;\n\n\n// FUNCTIONS //\n\nconst summaryTable = ( x, intercept, result, t ) => {\n\treturn (\n\t\t<Table bordered size=\"sm\">\n\t\t\t<thead>\n\t\t\t\t<tr>\n\t\t\t\t\t<th>{t('predictor')}</th>\n\t\t\t\t\t<th>{t('coefficient')}</th>\n\t\t\t\t</tr>\n\t\t\t</thead>\n\t\t\t<tbody>\n\t\t\t\t{ intercept ? <tr>\n\t\t\t\t\t<th>{t('intercept')}</th>\n\t\t\t\t\t<td>{result.beta[ 0 ].toFixed( 6 )}</td>\n\t\t\t\t</tr> : null }\n\t\t\t\t{x.map( ( name, idx ) => {\n\t\t\t\t\treturn (\n\t\t\t\t\t\t<tr key={idx} >\n\t\t\t\t\t\t\t<th>{name}</th>\n\t\t\t\t\t\t\t<td>{result.beta[ idx+Number(intercept) ].toFixed( 6 )}</td>\n\t\t\t\t\t\t</tr>\n\t\t\t\t\t);\n\t\t\t\t})}\n\t\t\t</tbody>\n\t\t</Table>\n\t);\n};\n\nfunction designMatrix( x, data, quantitative, intercept ) {\n\tif ( !isArray( x ) ) {\n\t\tx = [ x ];\n\t}\n\tconst matrix = [];\n\tconst predictors = [];\n\tconst hash = {};\n\tconst standardized = {};\n\tconst categoricalStats = {};\n\tconst nobs = data[ x[ 0 ] ].length;\n\tfor ( let j = 0; j < x.length; j++ ) {\n\t\tif ( contains( quantitative, x[ j ] ) ) {\n\t\t\tconst values = zScore( data[ x[ j ] ] );\n\t\t\tstandardized[ x[ j ] ] = values;\n\t\t\tpredictors.push( x[ j ] );\n\t\t} else {\n\t\t\tconst values = data[ x[ j ] ];\n\t\t\tconst counts = countBy( values, identity );\n\t\t\tconst categories = x[ j ].categories || objectKeys( counts );\n\t\t\tfor ( let k = intercept ? 1 : 0; k < categories.length; k++ ) {\n\t\t\t\tconst label = `${x[ j ]}_${categories[ k ]}`;\n\t\t\t\tpredictors.push( label );\n\t\t\t\tconst p = counts[ categories[ k ] ] / nobs;\n\t\t\t\tcategoricalStats[ label ] = {\n\t\t\t\t\tmu: p,\n\t\t\t\t\tsigma: sqrt( p * (1-p) )\n\t\t\t\t};\n\t\t\t}\n\t\t\thash[ x[ j ] ] = categories;\n\t\t}\n\t}\n\tfor ( let i = 0; i < nobs; i++ ) {\n\t\tconst row = [];\n\t\tif ( intercept ) {\n\t\t\trow.push( 1 );\n\t\t}\n\t\tfor ( let j = 0; j < x.length; j++ ) {\n\t\t\tif ( contains( quantitative, x[ j ] ) ) {\n\t\t\t\tconst values = standardized[ x[ j ] ];\n\t\t\t\trow.push( values[ i ] );\n\t\t\t} else {\n\t\t\t\tconst values = data[ x[ j ] ];\n\t\t\t\tconst categories = hash[ x[ j ] ];\n\t\t\t\tconst val = values[ i ];\n\t\t\t\tfor ( let k = intercept ? 1 : 0; k < categories.length; k++ ) {\n\t\t\t\t\tconst { mu, sigma } = categoricalStats[ `${x[ j ]}_${categories[ k ]}` ];\n\t\t\t\t\trow.push(\n\t\t\t\t\t\t( val === categories[ k ] ) ?\n\t\t\t\t\t\t( 1 - mu ) / sigma :\n\t\t\t\t\t\t-mu / sigma\n\t\t\t\t\t);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tmatrix.push( row );\n\t}\n\treturn { matrix, predictors, categoricalStats, standardized };\n}\n\nconst fitModel = ({ x, y, lambda, data, quantitative, intercept }) => {\n\ttry {\n\t\tlet yvalues = data[ y ];\n\t\tyvalues = zScore( yvalues, false, true );\n\t\tconst { matrix, predictors, categoricalStats, standardized } = designMatrix( x, data, quantitative, intercept );\n\t\tconst result = new LASSO( matrix, yvalues, lambda );\n\n\t\t// Convert back coefficients to original scale:\n\t\tif ( intercept ) {\n\t\t\tlet coefSum = 0.0;\n\t\t\tfor ( let i = 1; i < result.beta.length; i++ ) {\n\t\t\t\tconst pred = predictors[ i-1 ];\n\t\t\t\tif ( contains( quantitative, pred ) ) {\n\t\t\t\t\tresult.beta[ i ] *= yvalues.sigma / standardized[ pred ].sigma;\n\t\t\t\t\tcoefSum += ( result.beta[ i ] * standardized[ pred ].mu );\n\t\t\t\t} else {\n\t\t\t\t\tresult.beta[ i ] *= yvalues.sigma / categoricalStats[ pred ].sigma;\n\t\t\t\t\tcoefSum += ( result.beta[ i ] * categoricalStats[ pred ].mu );\n\t\t\t\t}\n\t\t\t}\n\t\t\tresult.beta[ 0 ] = yvalues.mu - coefSum;\n\t\t} else {\n\t\t\tfor ( let i = 0; i < result.beta.length; i++ ) {\n\t\t\t\tconst pred = predictors[ i ];\n\t\t\t\tif ( contains( quantitative, pred ) ) {\n\t\t\t\t\tresult.beta[ i ] *= yvalues.sigma / standardized[ pred ].sigma;\n\t\t\t\t} else {\n\t\t\t\t\tresult.beta[ i ] *= yvalues.sigma / categoricalStats[ pred ].sigma;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\treturn {\n\t\t\tpredictors,\n\t\t\tresult,\n\t\t\tyvalues\n\t\t};\n\t} catch ( _ ) {\n\t\treturn {};\n\t}\n};\n\n\n// MAIN //\n\n/**\n* LASSO regression.\n*\n* @property {Object} data - object of value arrays\n* @property {string} y - outcome variable\n* @property {Array<string>} x - one or more predictor variables\n* @property {Array<string>} quantitative - array of variables in `data` that are `quantitative`\n* @property {number} lambda - regularization parameter\n* @property {boolean} intercept - controls whether to fit a model with an intercept term\n* @property {Function} onPredict - callback invoked with predictions and residuals after model fitting\n*/\nclass LassoRegression extends Component {\n\tconstructor( props ) {\n\t\tsuper( props );\n\n\t\tCOUNTER += 1;\n\t\tconst { x, y, lambda, data, quantitative, intercept } = props;\n\t\tthis.state = {\n\t\t\t...fitModel({ x, y, lambda, data, quantitative, intercept }),\n\t\t\t...props\n\t\t};\n\t}\n\n\tstatic getDerivedStateFromProps( nextProps, prevState ) {\n\t\tif (\n\t\t\tnextProps.data !== prevState.data ||\n\t\t\tnextProps.quantitative !== prevState.quantitative ||\n\t\t\tnextProps.x !== prevState.x ||\n\t\t\tnextProps.y !== prevState.y ||\n\t\t\tnextProps.intercept !== prevState.intercept ||\n\t\t\tnextProps.lambda !== prevState.lambda\n\t\t) {\n\t\t\tconst { x, y, lambda, data, quantitative, intercept } = nextProps;\n\t\t\treturn {\n\t\t\t\t...fitModel({ x, y, lambda, data, quantitative, intercept }),\n\t\t\t\t...nextProps\n\t\t\t};\n\t\t}\n\t\treturn null;\n\t}\n\n\thandlePredict = () => {\n\t\tconst { matrix } = designMatrix( this.props.x, this.props.data, this.props.quantitative, this.props.intercept );\n\t\tlet { fitted, residuals } = this.state.result.predict( matrix );\n\n\t\t// Convert fitted values and residuals back to original scale before standardizing:\n\t\tfitted = multiply( fitted, this.state.yvalues.sigma );\n\t\tresiduals = multiply( residuals, -this.state.yvalues.sigma );\n\t\tthis.props.onPredict( fitted, residuals, COUNTER );\n\t}\n\n\trender() {\n\t\tconst { y, intercept, lambda, onPredict, t } = this.props;\n\t\tconst { result, predictors } = this.state;\n\t\tif ( !result ) {\n\t\t\treturn <Alert variant=\"danger\">{t('missing-attributes')}</Alert>;\n\t\t}\n\t\tif ( !isNumber( lambda ) ) {\n\t\t\treturn <Alert variant=\"danger\">{t('lambda-not-number')}</Alert>;\n\t\t}\n\t\treturn (\n\t\t\t<div style={{ overflowX: 'auto', width: '100%' }}>\n\t\t\t\t<span className=\"title\" >{t('lasso-title', { y, lambda: lambda.toFixed( 4 ), counter: COUNTER })}</span>\n\t\t\t\t{summaryTable( predictors, intercept, result, t )}\n\t\t\t\t<p>{result.testKKT() ? t('kkt-satisfied') : t('kkt-not-satisfied')}</p>\n\t\t\t\t{onPredict ? <Tooltip tooltip={t('use-model-to-predict-tooltip')} >\n\t\t\t\t\t<Button variant=\"secondary\" size=\"sm\" onClick={this.handlePredict}>{this.props.t('use-model-to-predict')}</Button>\n\t\t\t\t</Tooltip> : null}\n\t\t\t</div>\n\t\t);\n\t}\n}\n\n\n// PROPERTIES //\n\nLassoRegression.defaultProps = {\n\tlambda: 1e-3,\n\tintercept: true\n};\n\nLassoRegression.propTypes = {\n\tdata: PropTypes.object.isRequired,\n\ty: PropTypes.string.isRequired,\n\tx: PropTypes.oneOfType([\n\t\tPropTypes.arrayOf( PropTypes.string ),\n\t\tPropTypes.string\n\t]).isRequired,\n\tquantitative: PropTypes.arrayOf( PropTypes.string ).isRequired,\n\tlambda: PropTypes.number,\n\tintercept: PropTypes.bool\n};\n\n\n// EXPORTS //\n\nexport default withTranslation( 'StatisticalModels' )( LassoRegression );\n","// MODULES //\n\nimport isArrayLike from '@stdlib/assert/is-array-like';\nimport { isPrimitive as isNumber } from '@stdlib/assert/is-number';\n\n\n// MAIN //\n\n/**\n* Computes an element-wise subtraction.\n*\n* @param {NumberArray} arr - input array\n* @param {(NumberArray|number)} x - either an array of equal length or a scalar\n* @returns {NumberArray} output array\n*/\nfunction subtract( arr, x ) {\n\tconst isArr = isArrayLike( x );\n\tif ( !isArrayLike( arr ) ) {\n\t\tthrow new TypeError( 'invalid input argument. Must provide an array. Value: `' + arr + '`.' );\n\t}\n\tif ( !isArr && !isNumber( x ) ) {\n\t\tthrow new TypeError( 'invalid input argument. Second argument must either be an array or number primitive. Value: `' + x + '`.' );\n\t}\n\tconst len = arr.length;\n\tconst out = new Array( len );\n\n\t// Case 1: x is an array\n\tif ( isArr ) {\n\t\tif ( len !== x.length ) {\n\t\t\tthrow new Error( 'invalid input argument. Array to be added must have a length equal to that of the input array.' );\n\t\t}\n\t\tfor ( let i = 0; i < len; i++ ) {\n\t\t\tout[ i ] = arr[ i ] - x[ i ];\n\t\t}\n\t}\n\t// Case 2: scalar\n\telse {\n\t\tfor ( let i = 0; i < len; i++ ) {\n\t\t\tout[ i ] = arr[ i ] - x;\n\t\t}\n\t}\n\treturn out;\n}\n\n\n// EXPORTS //\n\nexport default subtract;\n"],"sourceRoot":""}